window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "data_algebra", "modulename": "data_algebra", "qualname": "", "type": "module", "doc": "<p><code>data_algebra</code><a href=\"https://github.com/WinVector/data_algebra\">https://github.com/WinVector/data_algebra</a> is a piped data wrangling system\nbased on Codd's relational algebra and experience working with dplyr at scale.  The primary \npurpose of the package is to support an easy to compose and maintain grammar of data processing\nsteps that in turn can be used to generate database specific SQL.  The package also implements\nthe same transforms for Pandas DataFrames. </p>\n\n<p>This package is still under initial development, so some parts are not yet implemented or tested, and APIs\nare subject to change.</p>\n\n<p>Mature, production ready <code>R</code><a href=\"https://www.r-project.org\">https://www.r-project.org</a> versions of the system are available as \nthe <code>rquery</code><a href=\"https://github.com/WinVector/rquery\">https://github.com/WinVector/rquery</a> and <code>rqdatatable</code><a href=\"https://github.com/WinVector/rqdatatable\">https://github.com/WinVector/rqdatatable</a> packages.</p>\n"}, {"fullname": "data_algebra.BigQuery", "modulename": "data_algebra.BigQuery", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.BigQuery.BigQueryModel", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel", "type": "class", "doc": "<p>A model of how SQL should be generated for BigQuery\nconnection should be google.cloud.bigquery.client.Client</p>\n"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.__init__", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_prefix"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.get_table_name", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.get_table_name", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_description"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.quote_table_name", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.quote_table_name", "type": "function", "doc": "<p>Quote a table name.</p>\n", "parameters": ["self", "table_description"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.execute", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.execute", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.read_query", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.insert_table", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.db_handle", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.db_handle", "type": "function", "doc": "<p>:param conn: database connection\n:param db_engine: optional sqlalchemy style engine (for closing)</p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle", "type": "class", "doc": "<p>Container for database connection handles.</p>\n"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.__init__", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.__init__", "type": "function", "doc": "<p>:param db_model: associated database model\n:param conn: database connection\n:param db_engine: optional sqlalchemy style engine (for closing)</p>\n", "parameters": ["self", "db_model", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.describe_bq_table", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.describe_bq_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_catalog", "table_schema", "table_name", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.query_to_csv", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.query_to_csv", "type": "function", "doc": "<p>Execute a query and save the results as a CSV file.</p>\n", "parameters": ["self", "q", "res_name"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.example_handle", "modulename": "data_algebra.BigQuery", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.\nNote: binds in a data_catalog and data schema prefix. So this handle is specific\nto one database.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.MySQL", "modulename": "data_algebra.MySQL", "qualname": "", "type": "module", "doc": "<p>Partial adapter of data algebra for MySQL. Not all data algebra operations are supported on this database at this time.</p>\n"}, {"fullname": "data_algebra.MySQL.MySQLModel", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for MySQL.\nAssuming we are using a sqlalchemy engine as our connection.</p>\n"}, {"fullname": "data_algebra.MySQL.MySQLModel.__init__", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.MySQL.MySQLModel.quote_identifier", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel.quote_identifier", "type": "function", "doc": "<p>Quote identifier.</p>\n", "parameters": ["self", "identifier"], "funcdef": "def"}, {"fullname": "data_algebra.MySQL.example_handle", "modulename": "data_algebra.MySQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet", "modulename": "data_algebra.OrderedSet", "qualname": "", "type": "module", "doc": "<p>Ordered set to enhance presentation of column names.</p>\n\n<p>Adapted from: https://stackoverflow.com/a/1653978</p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet", "type": "class", "doc": "<p>Ordered set to enhance presentation of column names.</p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.__init__", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.update", "type": "function", "doc": "<p>add/replace elements</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.add", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.add", "type": "function", "doc": "<p>add an element</p>\n", "parameters": ["self", "elem"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.discard", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.discard", "type": "function", "doc": "<p>delete an element</p>\n", "parameters": ["self", "elem"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.copy", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.copy", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.difference", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.difference", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.difference_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.difference_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.intersection", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.intersection", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.intersection_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.intersection_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.issubset", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.issubset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.issuperset", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.issuperset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.symmetric_difference", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.symmetric_difference", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.symmetric_difference_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.symmetric_difference_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.union", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.union", "type": "function", "doc": "<p>create new set union</p>\n", "parameters": ["self", "args"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.ordered_intersect", "modulename": "data_algebra.OrderedSet", "qualname": "ordered_intersect", "type": "function", "doc": "<p>Intersection of two iterables, ordered by a.</p>\n", "parameters": ["a", "b"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.ordered_union", "modulename": "data_algebra.OrderedSet", "qualname": "ordered_union", "type": "function", "doc": "<p>Union of two iterables, ordered by a first, then b.</p>\n", "parameters": ["a", "b"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.ordered_diff", "modulename": "data_algebra.OrderedSet", "qualname": "ordered_diff", "type": "function", "doc": "<p>a with b removed, a order preserved.</p>\n", "parameters": ["a", "b"], "funcdef": "def"}, {"fullname": "data_algebra.PostgreSQL", "modulename": "data_algebra.PostgreSQL", "qualname": "", "type": "module", "doc": "<p>PostgreSQL database adapter for data algebra.</p>\n"}, {"fullname": "data_algebra.PostgreSQL.PostgreSQLModel", "modulename": "data_algebra.PostgreSQL", "qualname": "PostgreSQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for PostgreSQL.\nAssuming we are using a sqlalchemy engine as our connection</p>\n"}, {"fullname": "data_algebra.PostgreSQL.PostgreSQLModel.__init__", "modulename": "data_algebra.PostgreSQL", "qualname": "PostgreSQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.PostgreSQL.example_handle", "modulename": "data_algebra.PostgreSQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.SQLite", "modulename": "data_algebra.SQLite", "qualname": "", "type": "module", "doc": "<p>Adapt data_algebra to SQLite database.</p>\n"}, {"fullname": "data_algebra.SQLite.MedianAgg", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg", "type": "class", "doc": "<p>Aggregate as median. SQLite user class.</p>\n"}, {"fullname": "data_algebra.SQLite.MedianAgg.__init__", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.MedianAgg.step", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.step", "type": "function", "doc": "<p>Observe value</p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.MedianAgg.finalize", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.finalize", "type": "function", "doc": "<p>Return result.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel", "type": "class", "doc": "<p>A model of how SQL should be generated for SQLite</p>\n"}, {"fullname": "data_algebra.SQLite.SQLiteModel.__init__", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.prepare_connection", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.prepare_connection", "type": "function", "doc": "<p>Insert user functions into db.</p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.insert_table", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.insert_table", "type": "function", "doc": "<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.natural_join_to_near_sql", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.natural_join_to_near_sql", "type": "function", "doc": "<p>Translate a join into SQL, converting right and full joins to replacement code (as SQLite doesn't have these).</p>\n", "parameters": ["self", "join_node", "using", "temp_id_source", "sql_format_options", "left_is_first"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.example_handle", "modulename": "data_algebra.SQLite", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL", "modulename": "data_algebra.SparkSQL", "qualname": "", "type": "module", "doc": "<p>SparkSQL adapter for the data algebra.</p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkConnection", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection", "type": "class", "doc": "<p>Holder for spark conext and session as a connection (defines close).</p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkConnection.__init__", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "spark_context", "spark_session"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkConnection.close", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection.close", "type": "function", "doc": "<p>Stop context and release reference to context and session.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for SparkSQL.</p>\n\n<p>Known issue: doesn't coalesce NaN</p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.__init__", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.execute", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.execute", "type": "function", "doc": "<p>Execute a SQL query or operator dag.</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.read_query", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.read_query", "type": "function", "doc": "<p>Execute a SQL query or operator dag, return result as Pandas data frame.</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.insert_table", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.insert_table", "type": "function", "doc": "<p>Insert table into database.</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.example_handle", "modulename": "data_algebra.SparkSQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.arrow", "modulename": "data_algebra.arrow", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.arrow.Arrow", "modulename": "data_algebra.arrow", "qualname": "Arrow", "type": "class", "doc": "<p>Arrow from category theory: see Steve Awody, \"Category Theory, 2nd Edition\", Oxford Univ. Press, 2010 pg. 4.</p>\n"}, {"fullname": "data_algebra.arrow.Arrow.__init__", "modulename": "data_algebra.arrow", "qualname": "Arrow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.dom", "modulename": "data_algebra.arrow", "qualname": "Arrow.dom", "type": "function", "doc": "<p>return domain, object at base of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.cod", "modulename": "data_algebra.arrow", "qualname": "Arrow.cod", "type": "function", "doc": "<p>return co-domain, object at head of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.apply_to", "modulename": "data_algebra.arrow", "qualname": "Arrow.apply_to", "type": "function", "doc": "<p>apply_to b, compose arrows (right to left)</p>\n", "parameters": ["self", "b"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.act_on", "modulename": "data_algebra.arrow", "qualname": "Arrow.act_on", "type": "function", "doc": "<p>act on X, must associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.transform", "type": "function", "doc": "<p>transform X, may or may not associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.fit", "modulename": "data_algebra.arrow", "qualname": "Arrow.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.fit_transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.get_feature_names", "modulename": "data_algebra.arrow", "qualname": "Arrow.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.get_params", "modulename": "data_algebra.arrow", "qualname": "Arrow.get_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.set_params", "modulename": "data_algebra.arrow", "qualname": "Arrow.set_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.inverse_transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.inverse_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow", "type": "class", "doc": "<p>Represent a dag of operators as a categorical arrow.</p>\n"}, {"fullname": "data_algebra.arrow.DataOpArrow.__init__", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pipeline", "free_table_key", "strict", "forbidden_to_produce"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.get_feature_names", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.apply_to", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.apply_to", "type": "function", "doc": "<p>replace self input table with b</p>\n", "parameters": ["self", "b"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.act_on", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.act_on", "type": "function", "doc": "<p>act on X, must associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.fit", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.fit", "type": "function", "doc": "<p>Learn input and output types from example, and return self</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.fit_transform", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.fit_transform", "type": "function", "doc": "<p>Learn input and output types from example, and return transform.</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.dom", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.dom", "type": "function", "doc": "<p>return domain, object at base of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.dom_as_table", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.dom_as_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.cod", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.cod", "type": "function", "doc": "<p>return co-domain, object at head of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.cod_as_table", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.cod_as_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.required_columns", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.required_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.forbidden_columns", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.forbidden_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.format_end_description", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.format_end_description", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "required_cols", "forbidden_cols", "align_right", "sep_width"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.fmt_as_arrow", "modulename": "data_algebra.arrow", "qualname": "fmt_as_arrow", "type": "function", "doc": "<p></p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.cdata", "modulename": "data_algebra.cdata", "qualname": "", "type": "module", "doc": "<p>Class for representing record structure transformations.</p>\n"}, {"fullname": "data_algebra.cdata.RecordSpecification", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification", "type": "class", "doc": "<p>Class to represent a multi-row data record.</p>\n"}, {"fullname": "data_algebra.cdata.RecordSpecification.__init__", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.__init__", "type": "function", "doc": "<p>:param control_table: data.frame describing record layout\n:param record_keys: array of record key column names\n       defaults to no columns.\n:param control_table_keys: array of control_table key column names,\n       defaults to first column for non-trivial blocks and no columns for rows.\n:param strict: logical, if True more checks on transform\n:param local_data_model: data.frame data model</p>\n", "parameters": ["self", "control_table", "record_keys", "control_table_keys", "strict", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.row_version", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.row_version", "type": "function", "doc": "<p>Return copy of record as a row record.</p>\n\n<p>:param include_record_keys: logical, if True include record keys as columns\n:return: column list</p>\n", "parameters": ["self", "include_record_keys"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.fmt", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.fmt", "type": "function", "doc": "<p>Prepare for printing</p>\n\n<p>:return: multi line string representation.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.map_to_rows", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.map_to_rows", "type": "function", "doc": "<p>Build a RecordMap mapping this RecordSpecification to rowrecs</p>\n\n<p>:return: RecordMap</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.map_from_rows", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.map_from_rows", "type": "function", "doc": "<p>Build a RecordMap mapping this RecordSpecification from rowrecs</p>\n\n<p>:return: RecordMap</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.blocks_to_rowrecs", "modulename": "data_algebra.cdata", "qualname": "blocks_to_rowrecs", "type": "function", "doc": "<p>Convert a block record (record spanning multiple rows) into a rowrecord (record in a single row).</p>\n\n<p>:param data: data frame to be transformed\n:param blocks_in: record specification\n:param local_data_model: pandas model.\n:return: transformed data frame</p>\n", "parameters": ["data", "blocks_in", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.rowrecs_to_blocks", "modulename": "data_algebra.cdata", "qualname": "rowrecs_to_blocks", "type": "function", "doc": "<p>Convert rowrecs (single row records) into block records (multiple row records).</p>\n\n<p>:param data: data frame to transform.\n:param blocks_out: record specification.\n:param check_blocks_out_keying: logical, if True confirm keying\n:param local_data_model: pandas data model\n:return: transformed data frame</p>\n", "parameters": ["data", "blocks_out", "check_blocks_out_keying", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap", "modulename": "data_algebra.cdata", "qualname": "RecordMap", "type": "class", "doc": "<p>Class for specifying general record to record transforms.</p>\n"}, {"fullname": "data_algebra.cdata.RecordMap.__init__", "modulename": "data_algebra.cdata", "qualname": "RecordMap.__init__", "type": "function", "doc": "<p>Build the transform specification. At least one of blocks_in or blocks_out must not be None.</p>\n\n<p>:param blocks_in: incoming record specification, None for row-records.\n:param blocks_out: outgoing record specification, None for row-records.</p>\n", "parameters": ["self", "blocks_in", "blocks_out"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.record_keys", "modulename": "data_algebra.cdata", "qualname": "RecordMap.record_keys", "type": "function", "doc": "<p>Return keys specifying which set of rows are in a record.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.example_input", "modulename": "data_algebra.cdata", "qualname": "RecordMap.example_input", "type": "function", "doc": "<p>Return example output record.</p>\n\n<p>:param local_data_model: optional Pandas data model.\n:return: example result data frame.</p>\n", "parameters": ["self", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.transform", "type": "function", "doc": "<p>Transform X records.</p>\n\n<p>:param X: data frame to be transformed.\n:param check_blocks_out_keying: logical, if True check output key constraints.\n:param local_data_model: pandas data model.\n:return: transformed data frame.</p>\n", "parameters": ["self", "X", "check_blocks_out_keying", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.compose", "modulename": "data_algebra.cdata", "qualname": "RecordMap.compose", "type": "function", "doc": "<p>Experimental method to compose transforms\n(self.compose(other)).transform(data) == self.transform(other.transform(data))</p>\n\n<p>:param other: another data_algebra.cdata.RecordMap\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.inverse", "modulename": "data_algebra.cdata", "qualname": "RecordMap.inverse", "type": "function", "doc": "<p>Return inverse transform.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fmt", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fmt", "type": "function", "doc": "<p>Format for informal presentation.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fit", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fit", "type": "function", "doc": "<p>No-op (sklearn pipeline interface)</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fit_transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fit_transform", "type": "function", "doc": "<p>transform() (sklearn pipeline interface)</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.get_feature_names", "modulename": "data_algebra.cdata", "qualname": "RecordMap.get_feature_names", "type": "function", "doc": "<p>Return columns produced (sklearn pipeline interface)</p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.get_params", "modulename": "data_algebra.cdata", "qualname": "RecordMap.get_params", "type": "function", "doc": "<p>Return emtpy dictionary (sklearn pipeline interface)</p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.set_params", "modulename": "data_algebra.cdata", "qualname": "RecordMap.set_params", "type": "function", "doc": "<p>No-op (sklearn pipeline interface)</p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.inverse_transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.inverse_transform", "type": "function", "doc": "<p>Perform inverse transform (sklearn pipeline interface)</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.pivot_blocks_to_rowrecs", "modulename": "data_algebra.cdata", "qualname": "pivot_blocks_to_rowrecs", "type": "function", "doc": "<p>Build a block records to row records map. This is very similar to a SQL pivot.</p>\n\n<p>:param attribute_key_column: column to identify record attribute keys\n:param attribute_value_column: column for record attribute values\n:param record_keys: names of key columns identifying row record blocks\n:param record_value_columns: names of columns to take row record values from\n:param local_data_model: data.frame data model\n:return: RecordMap</p>\n", "parameters": ["attribute_key_column", "attribute_value_column", "record_keys", "record_value_columns", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.pivot_rowrecs_to_blocks", "modulename": "data_algebra.cdata", "qualname": "pivot_rowrecs_to_blocks", "type": "function", "doc": "<p>Build a row records to block records map. This is very similar to a SQL unpivot.</p>\n\n<p>:param attribute_key_column: column to identify record attribute keys\n:param attribute_value_column: column for record attribute values\n:param record_keys: names of key columns identifying row record blocks\n:param record_value_columns: names of columns to take row record values from\n:param local_data_model: data.frame data model\n:return: RecordMap</p>\n", "parameters": ["attribute_key_column", "attribute_value_column", "record_keys", "record_value_columns", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.connected_components", "modulename": "data_algebra.connected_components", "qualname": "", "type": "module", "doc": "<p>Code for computing collected components.</p>\n"}, {"fullname": "data_algebra.connected_components.Component", "modulename": "data_algebra.connected_components", "qualname": "Component", "type": "class", "doc": "<p>Holder for a connected component.</p>\n"}, {"fullname": "data_algebra.connected_components.Component.__init__", "modulename": "data_algebra.connected_components", "qualname": "Component.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "item"], "funcdef": "def"}, {"fullname": "data_algebra.connected_components.connected_components", "modulename": "data_algebra.connected_components", "qualname": "connected_components", "type": "function", "doc": "<p>Compute connected components of undirected edges (f[i], g[i]).</p>\n\n<p>For the return value we are using the\ncategory formulation that these are the co-equalizer of f and g,\nmeaning it is a finest partition such that return[f[i]] = return[g[i]]\nfor all i.  We pick the least item in each component as the representation.\nThis is just a long way of saying: as each side of an edge is in the same\ncomponent, we return the assignment by labeling the edges by components\n(instead of the vertices).</p>\n\n<p>Not as fast as union/find but fast.</p>\n\n<p>f = [1, 4, 6, 2, 1]\ng = [2, 5, 7, 3, 7]\nres = connected_components(f, g)\nprint(res)</p>\n\n<p>:param f: list or vector of hashable/comparable items of length n\n:param g: list or vector of hashable/comparable items of length n\n:return: list of assignments of length n (map both f and g to same values.</p>\n", "parameters": ["f", "g"], "funcdef": "def"}, {"fullname": "data_algebra.data_model", "modulename": "data_algebra.data_model", "qualname": "", "type": "module", "doc": "<p>Interface for realizing the data algebra as a sequence of steps over an object.</p>\n"}, {"fullname": "data_algebra.data_model.DataModel", "modulename": "data_algebra.data_model", "qualname": "DataModel", "type": "class", "doc": "<p>Interface for realizing the data algebra as a sequence of steps over a Pandas like object.</p>\n"}, {"fullname": "data_algebra.data_model.DataModel.__init__", "modulename": "data_algebra.data_model", "qualname": "DataModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "presentation_model_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.data_frame", "modulename": "data_algebra.data_model", "qualname": "DataModel.data_frame", "type": "function", "doc": "<p>Build a new emtpy data frame.</p>\n\n<p>:param arg: optional argument passed to constructor.\n:return: data frame</p>\n", "parameters": ["self", "arg"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.is_appropriate_data_instance", "modulename": "data_algebra.data_model", "qualname": "DataModel.is_appropriate_data_instance", "type": "function", "doc": "<p>Check if df is our type of data frame.</p>\n", "parameters": ["self", "df"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.eval", "modulename": "data_algebra.data_model", "qualname": "DataModel.eval", "type": "function", "doc": "<p>Implementation of Pandas evaluation of operators</p>\n\n<p>:param op: ViewRepresentation to evaluate\n:param data_map: dictionary mapping table and view names to data frames\n:param narrow: if True narrow results to only columns anticipated\n:return: data frame result</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops", "modulename": "data_algebra.data_ops", "qualname": "", "type": "module", "doc": "<p>Realization of data operations.</p>\n"}, {"fullname": "data_algebra.data_ops.pretty_format_python", "modulename": "data_algebra.data_ops", "qualname": "pretty_format_python", "type": "function", "doc": "<p>Format Python code, using black.</p>\n\n<p>:param python_str: Python code\n:param black_mode: options for black\n:return: formatted Python code</p>\n", "parameters": ["python_str", "black_mode"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.__init__", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_names", "sources", "node_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.column_map", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.column_map", "type": "function", "doc": "<p>Build a map of column names to ColumnReferences</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.merged_rep_id", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.merged_rep_id", "type": "function", "doc": "<p>String key for lookups.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.ex", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["self", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.get_tables", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.get_tables", "type": "function", "doc": "<p>Get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_produced", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_produced", "type": "function", "doc": "<p>Return list of columns produced by operator dag.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_used_implementation_", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_used_implementation_", "type": "function", "doc": "<p>Implementation of columns used calculation, internal method.</p>\n", "parameters": ["self", "using", "columns_currently_using_records"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_used", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_used", "type": "function", "doc": "<p>Determine which columns are used from source tables.</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables\n(were not in declared structure, and interfere with column production).</p>\n\n<p>:param forbidden: optional incoming forbids.\n:return: dictionary operator keys to forbidden sets.</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_python_src_", "type": "function", "doc": "<p>Return text representing operations. Internal method, allows skipping of sources.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_python", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_python", "type": "function", "doc": "<p>Return Python source code for operations.</p>\n\n<p>:param indent: extra indent.\n:param strict: if False allow eliding of columns names and other long structures.\n:param pretty: if True re-format result with black.\n:param black_mode: black formatter parameters.</p>\n", "parameters": ["self", "indent", "strict", "pretty", "black_mode"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_sql", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_sql", "type": "function", "doc": "<p>Convert operator dag to SQL.</p>\n\n<p>:param db_model: database model\n:param sql_format_options: options for sql formatting\n:return: string representation of SQL query</p>\n", "parameters": ["self", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.check_constraints", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.check_constraints", "type": "function", "doc": "<p>Check tables supplied meet data consistency constraints.</p>\n\n<p>data_model: dictionary of column name lists.</p>\n", "parameters": ["self", "data_model", "strict"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.eval", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.eval", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames.</p>\n\n<p>:param data_map: map from table names to data frames\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param check_incoming_data_constraints: logical, if True check incoming data meets constraints\n:return: table result</p>\n", "parameters": ["self", "data_map", "data_model", "narrow", "check_incoming_data_constraints"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.transform", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.transform", "type": "function", "doc": "<p>Apply data transform to a table</p>\n\n<p>:param X: tale to apply to\n:param data_model: data model for Pandas execution\n:param narrow: logical, if True narrow number of result columns to specification\n:param check_incoming_data_constraints: logical, if True check incoming data meets constraints\n:return: transformed data frame</p>\n", "parameters": ["self", "X", "data_model", "narrow", "check_incoming_data_constraints"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.is_trivial_when_intermediate_", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.is_trivial_when_intermediate_", "type": "function", "doc": "<p>Return if True if operator can be eliminated from interior chain.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.as_table_description", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.as_table_description", "type": "function", "doc": "<p>Return representation of operator as a table description.</p>\n\n<p>:param table_name: table name to use.\n:param qualifiers: db qualifiers to annotate</p>\n", "parameters": ["self", "table_name", "qualifiers"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.extend_parsed_", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.extend_parsed_", "type": "function", "doc": "<p>Add new derived columns, can replace existing columns for parsed operations. Internal method.</p>\n\n<p>:param parsed_ops: dictionary of calculations to perform.\n:param partition_by: optional window partition specification, or 1.\n:param order_by: optional window ordering specification, or 1.\n:param reverse: optional order reversal specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.extend", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.extend", "type": "function", "doc": "<p>Add new derived columns, can replace existing columns.</p>\n\n<p>:param ops: dictionary of calculations to perform.\n:param partition_by: optional window partition specification, or 1.\n:param order_by: optional window ordering specification, or 1.\n:param reverse: optional order reversal specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.project_parsed_", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.project_parsed_", "type": "function", "doc": "<p>Compute projection, or grouped calculation for parsed ops. Internal method.</p>\n\n<p>:param parsed_ops: dictionary of calculations to perform, can be empty.\n:param group_by: optional group key(s) specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.project", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.project", "type": "function", "doc": "<p>Compute projection, or grouped calculation.</p>\n\n<p>:param ops: dictionary of calculations to perform, can be empty.\n:param group_by: optional group key(s) specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.natural_join", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.natural_join", "type": "function", "doc": "<p>Join self (left) results with b (right).</p>\n\n<p>:param b: second or right table to join to.\n:param by: list of join key column names.\n:param jointype: name of join type.\n:param check_all_common_keys_in_by: if True, raise if any non-key columns are common to tables.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.concat_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.concat_rows", "type": "function", "doc": "<p>Union or concatenate rows of self with rows of b.</p>\n\n<p>:param b: table with rows to add.\n:param id_column: optional name for new source identification column.\n:param a_name: source annotation to use for self/a.\n:param b_name: source annotation to use for b.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_rows_parsed_", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_rows_parsed_", "type": "function", "doc": "<p>Select rows matching parsed expr criteria. Internal method.</p>\n\n<p>:param parsed_expr: logical expression specifying desired rows.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_rows", "type": "function", "doc": "<p>Select rows matching expr criteria.</p>\n\n<p>:param expr: logical expression specifying desired rows.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.drop_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.drop_columns", "type": "function", "doc": "<p>Remove columns from result.</p>\n\n<p>:param column_deletions: list of columns to remove.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_columns", "type": "function", "doc": "<p>Narrow to columns in result.</p>\n\n<p>:param columns: list of columns to keep.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.rename_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.rename_columns", "type": "function", "doc": "<p>Rename columns.</p>\n\n<p>:param column_remapping: dictionary mapping new column names to old column sources (same\n                         direction as extend).\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.order_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.order_rows", "type": "function", "doc": "<p>Order rows by column set.</p>\n\n<p>:param columns: columns to order by.\n:param reverse: optional columns to reverse order.\n:param limit: optional row limit to impose on result.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.convert_records", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.convert_records", "type": "function", "doc": "<p>Apply a record mapping taking blocks_in to blocks_out structures.</p>\n\n<p>:param record_map: data_algebra.cdata.RecordMap transform specification\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription", "modulename": "data_algebra.data_ops", "qualname": "TableDescription", "type": "class", "doc": "<p>Describe columns, and qualifiers, of a table.</p>\n\n<p>Example:\n    from data_algebra.data_ops import *\n    d = TableDescription(table_name='d', column_names=['x', 'y'])\n    print(d)</p>\n"}, {"fullname": "data_algebra.data_ops.TableDescription.__init__", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name", "column_names", "qualifiers", "sql_meta", "head", "limit_was", "nrows"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.same_table_description_", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.same_table_description_", "type": "function", "doc": "<p>Return true if other is a description of the same table. Internal method, ingores data.</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.merged_rep_id", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.merged_rep_id", "type": "function", "doc": "<p>String key for lookups.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables\n(were not in declared structure, and interfere with column production).</p>\n\n<p>:param forbidden: optional incoming forbids.\n:return: dictionary operator keys to forbidden sets.</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.apply_to", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.get_tables", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.get_tables", "type": "function", "doc": "<p>get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.describe_table", "modulename": "data_algebra.data_ops", "qualname": "describe_table", "type": "function", "doc": "<p>:param d: pandas table to describe\n:param table_name: name of table\n:param qualifiers: optional, able qualifiers\n:param sql_meta: optional, sql meta information map\n:param row_limit: how many rows to sample\n:param keep_sample: logical, if True retain head of table\n:param keep_all: logical, if True retain all of table\n:return: TableDescription</p>\n", "parameters": ["d", "table_name", "qualifiers", "sql_meta", "row_limit", "keep_sample", "keep_all"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.table", "modulename": "data_algebra.data_ops", "qualname": "table", "type": "function", "doc": "<p>Capture a table for later use</p>\n\n<p>:param d: Pandas data frame to capture\n:param table_name: name for this table\n:return: a table description, with values retained</p>\n", "parameters": ["d", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.descr", "modulename": "data_algebra.data_ops", "qualname": "descr", "type": "function", "doc": "<p>Capture a named partial table as a description.</p>\n\n<p>:param kwargs: exactly one named table of the form table_name=table_value\n:return: a table description (not all values retained)</p>\n", "parameters": ["kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.data", "modulename": "data_algebra.data_ops", "qualname": "data", "type": "function", "doc": "<p>Capture a full table for later use. Exactly one of args/kwags can be set.</p>\n\n<p>:param args: at most one unnamed table of the form table_name=table_value\n:param kwargs: at most one named table of the form table_name=table_value\n:return: a table description, with all values retained</p>\n", "parameters": ["args", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode", "type": "class", "doc": "<p>Class representation of .extend() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.ExtendNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composable API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.check_extend_window_fns_", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.check_extend_window_fns_", "type": "function", "doc": "<p>Confirm extend functions are all compatible with windowing in Pandas. Internal function.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode", "type": "class", "doc": "<p>Class representation of .project() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.ProjectNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables\n(were not in declared structure, and interfere with column production).</p>\n\n<p>:param forbidden: optional incoming forbids.\n:return: dictionary operator keys to forbidden sets.</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode", "type": "class", "doc": "<p>Class representation of .select() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "ops"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode", "type": "class", "doc": "<p>Class representation of .select_columns() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables\n(were not in declared structure, and interfere with column production).</p>\n\n<p>:param forbidden: optional incoming forbids.\n:return: dictionary operator keys to forbidden sets.</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode", "type": "class", "doc": "<p>Class representation of .drop_columns() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables\n(were not in declared structure, and interfere with column production).</p>\n\n<p>:param forbidden: optional incoming forbids.\n:return: dictionary operator keys to forbidden sets.</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode", "type": "class", "doc": "<p>Class representation of .order_rows() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.is_trivial_when_intermediate_", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.is_trivial_when_intermediate_", "type": "function", "doc": "<p>Return if True if operator can be eliminated from interior of chain.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode", "type": "class", "doc": "<p>Class representation of .rename_columns() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables\n(were not in declared structure, and interfere with column production).</p>\n\n<p>:param forbidden: optional incoming forbids.\n:return: dictionary operator keys to forbidden sets.</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode", "type": "class", "doc": "<p>Class representation of .natural_join() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode", "type": "class", "doc": "<p>Class representation of .concat_rows() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode", "type": "class", "doc": "<p>Class representation of .convert_records() method/step.</p>\n"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SQLNode", "modulename": "data_algebra.data_ops", "qualname": "SQLNode", "type": "class", "doc": "<p>Class representation of user SQL step in pipeline. Can be used to start a pipeline instead of a TableDescription.</p>\n"}, {"fullname": "data_algebra.data_ops.SQLNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "SQLNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "sql", "column_names", "view_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SQLNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "SQLNode.apply_to", "type": "function", "doc": "<p>Apply self to operator DAG a. Basic OperatorPlatform, composabile API.</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SQLNode.get_tables", "modulename": "data_algebra.data_ops", "qualname": "SQLNode.get_tables", "type": "function", "doc": "<p>Get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SQLNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "SQLNode.columns_used_from_sources", "type": "function", "doc": "<p>Get columns used from sources. Internal method.</p>\n\n<p>:param using: optional column restriction.\n:return: list of order sets (list parallel to sources).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SQLNode.to_python_src_", "modulename": "data_algebra.data_ops", "qualname": "SQLNode.to_python_src_", "type": "function", "doc": "<p>Return text representing operations.</p>\n\n<p>:param indent: additional indent to apply in formatting.\n:param strict: if False allow eliding of columns names and other long structures.\n:param print_sources: logical, print children.</p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SQLNode.to_near_sql_implementation_", "modulename": "data_algebra.data_ops", "qualname": "SQLNode.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert operator dag into NearSQL type for translation to SQL string.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction set\n:param temp_id_source: source of temporary ids\n:param sql_format_options: options for sql formatting\n:return: data_algebra.near_sql.NearSQL</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ex", "modulename": "data_algebra.data_ops", "qualname": "ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param d: data algebra pipeline or OpC container to evaluate.\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["d", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types", "modulename": "data_algebra.data_ops_types", "qualname": "", "type": "module", "doc": "<p>Type defs for data operations.</p>\n"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform", "type": "class", "doc": "<p>Abstract class representing ability to apply data_algebra operations.</p>\n"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.__init__", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.eval", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.eval", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames.</p>\n\n<p>:param data_map: map from table names to data frames\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:return: table result</p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.transform", "type": "function", "doc": "<p>apply self to data frame X, may or may not commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model: implementation to use\n:param narrow: logical, if True don't copy unexpected columns\n:param check_incoming_data_constraints: logical, if True check incoming data meets constraints\n:return: transformed data frame</p>\n", "parameters": ["self", "X", "data_model", "narrow", "check_incoming_data_constraints"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.act_on", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.act_on", "type": "function", "doc": "<p>apply self to data frame X, must commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.apply_to", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.add", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.add", "type": "function", "doc": "<p>other.apply_to(self)</p>\n\n<p>:param other:\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.use", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.use", "type": "function", "doc": "<p>Apply f as if it was a method on this chain.\nDefined as return f(self, <em>args, *</em>kwargs).</p>\n\n<p>:param user_function: function to apply\n:param args: additional positional arguments\n:param kwargs: additional keyword arguments</p>\n", "parameters": ["self", "user_function", "args", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.ex", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["self", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_tables", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_tables", "type": "function", "doc": "<p>Get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.columns_produced", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.columns_produced", "type": "function", "doc": "<p>Return list of columns produced by pipeline.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.to_near_sql_implementation_", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert to NearSQL as a step in converting to a SQL string. Internal method.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction\n:param temp_id_source: temporary id source.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.extend_parsed_", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.extend_parsed_", "type": "function", "doc": "<p>Add new derived columns, can replace existing columns for parsed operations. Internal method.</p>\n\n<p>:param parsed_ops: dictionary of calculations to perform.\n:param partition_by: optional window partition specification.\n:param order_by: optional window ordering specification.\n:param reverse: optional order reversal specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.project_parsed_", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.project_parsed_", "type": "function", "doc": "<p>Compute projection, or grouped calculation for parsed ops. Internal method.</p>\n\n<p>:param parsed_ops: dictionary of calculations to perform, can be empty.\n:param group_by: optional group key(s) specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_rows_parsed_", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_rows_parsed_", "type": "function", "doc": "<p>Select rows matching parsed expr criteria. Internal method.</p>\n\n<p>:param parsed_expr: logical expression specifying desired rows.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.extend", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.extend", "type": "function", "doc": "<p>Add new derived columns, can replace existing columns.</p>\n\n<p>:param ops: dictionary of calculations to perform.\n:param partition_by: optional window partition specification.\n:param order_by: optional window ordering specification.\n:param reverse: optional order reversal specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.project", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.project", "type": "function", "doc": "<p>Compute projection, or grouped calculation.</p>\n\n<p>:param ops: dictionary of calculations to perform, can be empty.\n:param group_by: optional group key(s) specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.natural_join", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.natural_join", "type": "function", "doc": "<p>Join self (left) results with b (right).</p>\n\n<p>:param b: second or right table to join to.\n:param by: list of join key column names.\n:param jointype: name of join type.\n:param check_all_common_keys_in_by: if True, raise if any non-key columns are common to tables.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.concat_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.concat_rows", "type": "function", "doc": "<p>Union or concatenate rows of self with rows of b.</p>\n\n<p>:param b: table with rows to add.\n:param id_column: optional name for new source identification column.\n:param a_name: source annotation to use for self/a.\n:param b_name: source annotation to use for b.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_rows", "type": "function", "doc": "<p>Select rows matching expr criteria.</p>\n\n<p>:param expr: logical expression specifying desired rows.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.drop_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.drop_columns", "type": "function", "doc": "<p>Remove columns from result.</p>\n\n<p>:param column_deletions: list of columns to remove.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_columns", "type": "function", "doc": "<p>Narrow to columns in result.</p>\n\n<p>:param columns: list of columns to keep.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.rename_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.rename_columns", "type": "function", "doc": "<p>Rename columns.</p>\n\n<p>:param column_remapping: dictionary mapping new column names to old column sources (same\n                         direction as extend).\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.order_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.order_rows", "type": "function", "doc": "<p>Order rows by column set.</p>\n\n<p>:param columns: columns to order by.\n:param reverse: optional columns to reverse order.\n:param limit: optional row limit to impose on result.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.convert_records", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.convert_records", "type": "function", "doc": "<p>Apply a record mapping taking blocks_in to blocks_out structures.</p>\n\n<p>:param record_map: data_algebra.cdata.RecordMap transform specification\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.map_records", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.map_records", "type": "function", "doc": "<p>Apply a record mapping taking blocks_in to blocks_out structures.</p>\n\n<p>:param blocks_in: Optional incoming record specification\n:param blocks_out: Optional incoming record specification\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "blocks_in", "blocks_out"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.fit", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.fit", "type": "function", "doc": "<p>sklearn interface, fit() is a noop</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.fit_transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.fit_transform", "type": "function", "doc": "<p>sklearn interface, fit() is a noop</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_feature_names", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_feature_names", "type": "function", "doc": "<p>sklearn interface, return columns</p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_params", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_params", "type": "function", "doc": "<p>sklearn interface, noop</p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.set_params", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.set_params", "type": "function", "doc": "<p>sklearn interface, noop</p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.inverse_transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.inverse_transform", "type": "function", "doc": "<p>sklearn interface, raise</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_utils", "modulename": "data_algebra.data_ops_utils", "qualname": "", "type": "module", "doc": "<p>Utility to merge extend operations, when appropriate.</p>\n"}, {"fullname": "data_algebra.data_ops_utils.try_to_merge_ops", "modulename": "data_algebra.data_ops_utils", "qualname": "try_to_merge_ops", "type": "function", "doc": "<p>Try to merge two extends into one. Return merged op, or None if not possible.</p>\n", "parameters": ["ops1", "ops2"], "funcdef": "def"}, {"fullname": "data_algebra.db_model", "modulename": "data_algebra.db_model", "qualname": "", "type": "module", "doc": "<p>Base class for SQL adapters for data algebra.</p>\n"}, {"fullname": "data_algebra.db_model.SQLFormatOptions", "modulename": "data_algebra.db_model", "qualname": "SQLFormatOptions", "type": "class", "doc": "<p>Simple class for holding SQL formatting options</p>\n"}, {"fullname": "data_algebra.db_model.SQLFormatOptions.__init__", "modulename": "data_algebra.db_model", "qualname": "SQLFormatOptions.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "use_with", "annotate", "sql_indent", "initial_commas"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel", "modulename": "data_algebra.db_model", "qualname": "DBModel", "type": "class", "doc": "<p>A model of how SQL should be generated for a given database.</p>\n"}, {"fullname": "data_algebra.db_model.DBModel.__init__", "modulename": "data_algebra.db_model", "qualname": "DBModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "identifier_quote", "string_quote", "sql_formatters", "op_replacements", "local_data_model", "on_start", "on_end", "on_joiner", "drop_text", "string_type", "supports_with", "allow_extend_merges", "default_SQL_format_options", "union_all_term_start", "union_all_term_end"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.db_handle", "modulename": "data_algebra.db_model", "qualname": "DBModel.db_handle", "type": "function", "doc": "<p>:param conn: database connection\n:param db_engine: optional sqlalchemy style engine (for closing)</p>\n", "parameters": ["self", "conn", "db_engine"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.prepare_connection", "modulename": "data_algebra.db_model", "qualname": "DBModel.prepare_connection", "type": "function", "doc": "<p>Do any augmentation or preperation of a database connection. Example: adding stored procedures.</p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.execute", "modulename": "data_algebra.db_model", "qualname": "DBModel.execute", "type": "function", "doc": "<p>:param conn: database connectionex\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read_query", "modulename": "data_algebra.db_model", "qualname": "DBModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_exists", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_exists", "type": "function", "doc": "<p>Return true if table exists.</p>\n", "parameters": ["self", "conn", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.drop_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.drop_table", "type": "function", "doc": "<p>Remove a table.</p>\n", "parameters": ["self", "conn", "table_name", "check"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.insert_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.read_table", "type": "function", "doc": "<p>Return table contents as a Pandas data frame.</p>\n", "parameters": ["self", "conn", "table_name", "qualifiers", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read", "modulename": "data_algebra.db_model", "qualname": "DBModel.read", "type": "function", "doc": "<p>Return table as a pandas data frame for table description.</p>\n", "parameters": ["self", "conn", "table"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_identifier", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_identifier", "type": "function", "doc": "<p>Quote identifier.</p>\n", "parameters": ["self", "identifier"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_table_name", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_table_name", "type": "function", "doc": "<p>Quote a table name.</p>\n", "parameters": ["self", "table_description"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_string", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_string", "type": "function", "doc": "<p>Quote a string value.</p>\n", "parameters": ["self", "string"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.value_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.value_to_sql", "type": "function", "doc": "<p>Convert a value to valid SQL.</p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_values_to_sql_str_list", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_values_to_sql_str_list", "type": "function", "doc": "<p>Convert a table of values to a SQL. Only for small tables.</p>\n", "parameters": ["self", "v", "result_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.expr_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.expr_to_sql", "type": "function", "doc": "<p>Convert an expression to SQL.</p>\n", "parameters": ["self", "expression", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_def_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_def_to_near_sql", "type": "function", "doc": "<p>Convert a table description to NearSQL.</p>\n", "parameters": ["self", "table_def", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.extend_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.extend_to_near_sql", "type": "function", "doc": "<p>Convert an extend step into NearSQL.</p>\n", "parameters": ["self", "extend_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.project_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.project_to_near_sql", "type": "function", "doc": "<p>Convert a project step to NearSQL</p>\n", "parameters": ["self", "project_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.select_rows_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.select_rows_to_near_sql", "type": "function", "doc": "<p>Convert select rows into NearSQL</p>\n", "parameters": ["self", "select_rows_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.select_columns_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.select_columns_to_near_sql", "type": "function", "doc": "<p>Convert select columns to NearSQL.</p>\n", "parameters": ["self", "select_columns_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.drop_columns_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.drop_columns_to_near_sql", "type": "function", "doc": "<p>Convert drop columns to NearSQL</p>\n", "parameters": ["self", "drop_columns_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.order_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.order_to_near_sql", "type": "function", "doc": "<p>Convert order rows to NearSQL.</p>\n", "parameters": ["self", "order_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.rename_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.rename_to_near_sql", "type": "function", "doc": "<p>Convert rename columns to NearSQL.</p>\n", "parameters": ["self", "rename_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.natural_join_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.natural_join_to_near_sql", "type": "function", "doc": "<p>Convert natural join into NearSQL.</p>\n", "parameters": ["self", "join_node", "using", "temp_id_source", "sql_format_options", "left_is_first"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.concat_rows_to_near_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.concat_rows_to_near_sql", "type": "function", "doc": "<p>Convert concat rows into NearSQL.</p>\n", "parameters": ["self", "concat_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.to_sql", "type": "function", "doc": "<p>Convert ViewRepresentation into SQL string.</p>\n", "parameters": ["self", "ops", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.row_recs_to_blocks_query_str_list_pair", "modulename": "data_algebra.db_model", "qualname": "DBModel.row_recs_to_blocks_query_str_list_pair", "type": "function", "doc": "<p>Convert row recs to blocks transformation into structures to help with SQL conversion.</p>\n", "parameters": ["self", "record_spec"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.blocks_to_row_recs_query_str_list_pair", "modulename": "data_algebra.db_model", "qualname": "DBModel.blocks_to_row_recs_query_str_list_pair", "type": "function", "doc": "<p>Convert blocks to row recs transform into structures to help with SQL translation.</p>\n", "parameters": ["self", "record_spec"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.enc_term_", "modulename": "data_algebra.db_model", "qualname": "DBModel.enc_term_", "type": "function", "doc": "<p>encode and name a term for use in a SQL expression</p>\n", "parameters": ["self", "k", "terms"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.convert_nearsql_container_subsql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.convert_nearsql_container_subsql_", "type": "function", "doc": "<p>Convert sub-SQL into list of SQL string lines.</p>\n", "parameters": ["self", "nearsql_container", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlcte_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlcte_to_sql_str_list_", "type": "function", "doc": "<p>Convert SQL common table expression to list of SQL string lines.</p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqltable_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqltable_to_sql_str_list_", "type": "function", "doc": "<p>Convert SQL table description to list of SQL string lines.</p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlunary_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlunary_to_sql_str_list_", "type": "function", "doc": "<p>Convert SQL unary operation to list of SQL string lines.</p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlrawq_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlrawq_to_sql_str_list_", "type": "function", "doc": "<p>Convert user SQL query to list of SQL string lines.</p>\n", "parameters": ["self", "near_sql", "sql_format_options", "add_select"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlbinary_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlbinary_to_sql_str_list_", "type": "function", "doc": "<p>Convert SQL binary operation to list of SQL string lines.</p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle", "modulename": "data_algebra.db_model", "qualname": "DBHandle", "type": "class", "doc": "<p>Container for database connection handles.</p>\n"}, {"fullname": "data_algebra.db_model.DBHandle.__init__", "modulename": "data_algebra.db_model", "qualname": "DBHandle.__init__", "type": "function", "doc": "<p>:param db_model: associated database model\n:param conn: database connection\n:param db_engine: optional sqlalchemy style engine (for closing)</p>\n", "parameters": ["self", "db_model", "conn", "db_engine"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.read_query", "modulename": "data_algebra.db_model", "qualname": "DBHandle.read_query", "type": "function", "doc": "<p>Return results of query as a Pandas table.</p>\n", "parameters": ["self", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.describe_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.describe_table", "type": "function", "doc": "<p>Return a description of a database table.</p>\n", "parameters": ["self", "table_name", "qualifiers", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.execute", "modulename": "data_algebra.db_model", "qualname": "DBHandle.execute", "type": "function", "doc": "<p>Execute a SQL query or operator dag.</p>\n", "parameters": ["self", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.drop_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.drop_table", "type": "function", "doc": "<p>Remove a table.</p>\n", "parameters": ["self", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.insert_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.insert_table", "type": "function", "doc": "<p>Insert a table into the database.</p>\n", "parameters": ["self", "d", "table_name", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.to_sql", "modulename": "data_algebra.db_model", "qualname": "DBHandle.to_sql", "type": "function", "doc": "<p>Convert operations into SQL</p>\n", "parameters": ["self", "ops", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.query_to_csv", "modulename": "data_algebra.db_model", "qualname": "DBHandle.query_to_csv", "type": "function", "doc": "<p>Execute a query and save the results as a CSV file.</p>\n", "parameters": ["self", "q", "res_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.table_values_to_sql_str_list", "modulename": "data_algebra.db_model", "qualname": "DBHandle.table_values_to_sql_str_list", "type": "function", "doc": "<p>Convert a table of values to a SQL. Only for small tables.</p>\n", "parameters": ["self", "v", "result_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.close", "modulename": "data_algebra.db_model", "qualname": "DBHandle.close", "type": "function", "doc": "<p>Dispose of engine, or close connection.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_parse", "modulename": "data_algebra.expr_parse", "qualname": "", "type": "module", "doc": "<p>Parse expressions.</p>\n"}, {"fullname": "data_algebra.expr_parse.parse_assignments_in_context", "modulename": "data_algebra.expr_parse", "qualname": "parse_assignments_in_context", "type": "function", "doc": "<p>Convert all entries of ops map to Term-expressions</p>\n\n<p>:param ops: dictionary from strings to expressions (either Terms or strings)\n:param view: a data_algebra.data_ops.ViewRepresentation\n:return:</p>\n", "parameters": ["ops", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep", "modulename": "data_algebra.expr_rep", "qualname": "", "type": "module", "doc": "<p>Represent data processing expressions.</p>\n"}, {"fullname": "data_algebra.expr_rep.PythonText", "modulename": "data_algebra.expr_rep", "qualname": "PythonText", "type": "class", "doc": "<p>Class for holding text representation of Python, with possible additional annotations.\nstr() method returns only the text for interoperability.</p>\n"}, {"fullname": "data_algebra.expr_rep.PythonText.__init__", "modulename": "data_algebra.expr_rep", "qualname": "PythonText.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "s", "is_in_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm", "type": "class", "doc": "<p>abstract base class, without combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.PreTerm.__init__", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.is_equal", "type": "function", "doc": "<p>Check if this expression code is the same as another expression.</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.get_views", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.replace_view", "type": "function", "doc": "<p>Move expression to a new view.</p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.evaluate", "type": "function", "doc": "<p>Evaluate expression, taking data from data_frame.</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.to_python", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool, if True put parens around complex expressions that don't already have a grouper.\n:return: PythonText</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.to_source", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.to_source", "type": "function", "doc": "<p>Convert to source code.</p>\n\n<p>:param want_inline_parens: bool, if True put parens around complex expressions that don't already have a grouper.\n:param dialect: dialect to emit (not currently used)\n:return: PythonText</p>\n", "parameters": ["self", "want_inline_parens", "dialect"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term", "modulename": "data_algebra.expr_rep", "qualname": "Term", "type": "class", "doc": "<p>Abstract intermediate class with combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.Term.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Term.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sign", "modulename": "data_algebra.expr_rep", "qualname": "Term.sign", "type": "function", "doc": "<p>Return -1, 0, 1 as sign of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sin", "modulename": "data_algebra.expr_rep", "qualname": "Term.sin", "type": "function", "doc": "<p>Return trigometric sin() (in radians) of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cos", "modulename": "data_algebra.expr_rep", "qualname": "Term.cos", "type": "function", "doc": "<p>Return trigometric cos() (in radians) of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arcsin", "modulename": "data_algebra.expr_rep", "qualname": "Term.arcsin", "type": "function", "doc": "<p>Return trigometric arcsin() (in radians) of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arccos", "modulename": "data_algebra.expr_rep", "qualname": "Term.arccos", "type": "function", "doc": "<p>Return trigometric arccos() (in radians) of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctan", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctan", "type": "function", "doc": "<p>Return trigometric arctan() (in radians) of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctan2", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctan2", "type": "function", "doc": "<p>Return trigometric arctan2() (in radians) of item (vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sinh", "modulename": "data_algebra.expr_rep", "qualname": "Term.sinh", "type": "function", "doc": "<p>Return hyperbolic sinh() of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cosh", "modulename": "data_algebra.expr_rep", "qualname": "Term.cosh", "type": "function", "doc": "<p>Return hyperbolic cosh() of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.tanh", "modulename": "data_algebra.expr_rep", "qualname": "Term.tanh", "type": "function", "doc": "<p>Return hyperbolic tanh() of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arcsinh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arcsinh", "type": "function", "doc": "<p>Return hyperbolic arcsinh() of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arccosh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arccosh", "type": "function", "doc": "<p>Return hyperbolic arccosh() of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctanh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctanh", "type": "function", "doc": "<p>Return hyperbolic arctanh() of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.floor", "modulename": "data_algebra.expr_rep", "qualname": "Term.floor", "type": "function", "doc": "<p>Return floor() (largest int no larger than, as real type) of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ceil", "modulename": "data_algebra.expr_rep", "qualname": "Term.ceil", "type": "function", "doc": "<p>Return ceil() (smallest int no smaller than, as real type) of item (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sum", "modulename": "data_algebra.expr_rep", "qualname": "Term.sum", "type": "function", "doc": "<p>Return sum() of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumprod", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumprod", "type": "function", "doc": "<p>Return cumprod() of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumsum", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumsum", "type": "function", "doc": "<p>Return cumsum() of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.exp", "modulename": "data_algebra.expr_rep", "qualname": "Term.exp", "type": "function", "doc": "<p>Return exp() of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.expm1", "modulename": "data_algebra.expr_rep", "qualname": "Term.expm1", "type": "function", "doc": "<p>Return exp() - 1 of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log", "modulename": "data_algebra.expr_rep", "qualname": "Term.log", "type": "function", "doc": "<p>Return base e logarithm of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log10", "modulename": "data_algebra.expr_rep", "qualname": "Term.log10", "type": "function", "doc": "<p>Return base 10 logarithm of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log1p", "modulename": "data_algebra.expr_rep", "qualname": "Term.log1p", "type": "function", "doc": "<p>Return base e logarithm of 1 + items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.mod", "modulename": "data_algebra.expr_rep", "qualname": "Term.mod", "type": "function", "doc": "<p>Return modulo of items (vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.remainder", "modulename": "data_algebra.expr_rep", "qualname": "Term.remainder", "type": "function", "doc": "<p>Return remainder of items (vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sqrt", "modulename": "data_algebra.expr_rep", "qualname": "Term.sqrt", "type": "function", "doc": "<p>Return sqrt of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.abs", "modulename": "data_algebra.expr_rep", "qualname": "Term.abs", "type": "function", "doc": "<p>Return absolute value of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.maximum", "modulename": "data_algebra.expr_rep", "qualname": "Term.maximum", "type": "function", "doc": "<p>Return per row maximum of items and other (propogate missing, vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.minimum", "modulename": "data_algebra.expr_rep", "qualname": "Term.minimum", "type": "function", "doc": "<p>Return per row minimum of items and other (propogate missing, vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.fmax", "modulename": "data_algebra.expr_rep", "qualname": "Term.fmax", "type": "function", "doc": "<p>Return per row fmax of items and other (ignore missing, vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.fmin", "modulename": "data_algebra.expr_rep", "qualname": "Term.fmin", "type": "function", "doc": "<p>Return per row fmin of items and other (ignore missing, vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.round", "modulename": "data_algebra.expr_rep", "qualname": "Term.round", "type": "function", "doc": "<p>Return rounded values (nearest integer, subject to some rules) as real (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.around", "modulename": "data_algebra.expr_rep", "qualname": "Term.around", "type": "function", "doc": "<p>Return rounded values (given numer of decimals) as real (vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.all", "modulename": "data_algebra.expr_rep", "qualname": "Term.all", "type": "function", "doc": "<p>Return True if all items True (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.any", "modulename": "data_algebra.expr_rep", "qualname": "Term.any", "type": "function", "doc": "<p>Return True if any items True (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.bfill", "modulename": "data_algebra.expr_rep", "qualname": "Term.bfill", "type": "function", "doc": "<p>Return vector with missing vallues filled (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.count", "modulename": "data_algebra.expr_rep", "qualname": "Term.count", "type": "function", "doc": "<p>Return number of non-NA cells (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumcount", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumcount", "type": "function", "doc": "<p>Return cumulative number of non-NA cells (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cummax", "modulename": "data_algebra.expr_rep", "qualname": "Term.cummax", "type": "function", "doc": "<p>Return cumulative maximum (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cummin", "modulename": "data_algebra.expr_rep", "qualname": "Term.cummin", "type": "function", "doc": "<p>Return cumulative minimum (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ffill", "modulename": "data_algebra.expr_rep", "qualname": "Term.ffill", "type": "function", "doc": "<p>Return vector with missing vallues filled (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_monotonic_decreasing", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_monotonic_decreasing", "type": "function", "doc": "<p>Return vector True if monotonic decreasing (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_monotonic_increasing", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_monotonic_increasing", "type": "function", "doc": "<p>Return vector True if monotonic increasing (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.last", "modulename": "data_algebra.expr_rep", "qualname": "Term.last", "type": "function", "doc": "<p>Return last (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.max", "modulename": "data_algebra.expr_rep", "qualname": "Term.max", "type": "function", "doc": "<p>Return last (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.mean", "modulename": "data_algebra.expr_rep", "qualname": "Term.mean", "type": "function", "doc": "<p>Return mean (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.median", "modulename": "data_algebra.expr_rep", "qualname": "Term.median", "type": "function", "doc": "<p>Return median (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.min", "modulename": "data_algebra.expr_rep", "qualname": "Term.min", "type": "function", "doc": "<p>Return min (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nunique", "modulename": "data_algebra.expr_rep", "qualname": "Term.nunique", "type": "function", "doc": "<p>Return number of unique items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.rank", "modulename": "data_algebra.expr_rep", "qualname": "Term.rank", "type": "function", "doc": "<p>Return item rangings (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.size", "modulename": "data_algebra.expr_rep", "qualname": "Term.size", "type": "function", "doc": "<p>Return number of items (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.std", "modulename": "data_algebra.expr_rep", "qualname": "Term.std", "type": "function", "doc": "<p>Return standard devaition (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.var", "modulename": "data_algebra.expr_rep", "qualname": "Term.var", "type": "function", "doc": "<p>Return variance (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.shift", "modulename": "data_algebra.expr_rep", "qualname": "Term.shift", "type": "function", "doc": "<p>Return shifted items (vectorized).</p>\n", "parameters": ["self", "periods"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_null", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_null", "type": "function", "doc": "<p>Return which items are null (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_bad", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_bad", "type": "function", "doc": "<p>Return which items are bad (null or nan) (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.if_else", "modulename": "data_algebra.expr_rep", "qualname": "Term.if_else", "type": "function", "doc": "<p>Vectorized selection between two argument vectors.</p>\n", "parameters": ["self", "x", "y"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_in", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_in", "type": "function", "doc": "<p>Set membership (vectorized).</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.concat", "modulename": "data_algebra.expr_rep", "qualname": "Term.concat", "type": "function", "doc": "<p>Concatinate strings (vectorized).</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.coalesce", "modulename": "data_algebra.expr_rep", "qualname": "Term.coalesce", "type": "function", "doc": "<p>Replace missing values with alternative (vectorized).</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.co_equalizer", "modulename": "data_algebra.expr_rep", "qualname": "Term.co_equalizer", "type": "function", "doc": "<p>Compute the connected components (co-equalizer).</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.mapv", "modulename": "data_algebra.expr_rep", "qualname": "Term.mapv", "type": "function", "doc": "<p>Map values (vectorized).</p>\n", "parameters": ["self", "value_map", "default_value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.as_int64", "modulename": "data_algebra.expr_rep", "qualname": "Term.as_int64", "type": "function", "doc": "<p>Cast as int (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.as_str", "modulename": "data_algebra.expr_rep", "qualname": "Term.as_str", "type": "function", "doc": "<p>Cast as string (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.trimstr", "modulename": "data_algebra.expr_rep", "qualname": "Term.trimstr", "type": "function", "doc": "<p>Trim string start (inclusive) to stop (exclusive) (vectorized).</p>\n", "parameters": ["self", "start", "stop"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.coalesce_0", "modulename": "data_algebra.expr_rep", "qualname": "Term.coalesce_0", "type": "function", "doc": "<p>Replace missing values with zero (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.datetime_to_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.datetime_to_date", "type": "function", "doc": "<p>Convert date time to date (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.parse_datetime", "modulename": "data_algebra.expr_rep", "qualname": "Term.parse_datetime", "type": "function", "doc": "<p>Parse string as a date time (vectorized).</p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.parse_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.parse_date", "type": "function", "doc": "<p>Parse string as a date (vectorized).</p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.format_datetime", "modulename": "data_algebra.expr_rep", "qualname": "Term.format_datetime", "type": "function", "doc": "<p>Format string as a date time (vectorized).</p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.format_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.format_date", "type": "function", "doc": "<p>Format string as a date (vectorized).</p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofweek", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofweek", "type": "function", "doc": "<p>Convert date to date of week (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofyear", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofyear", "type": "function", "doc": "<p>Convert date to date of year (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofmonth", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofmonth", "type": "function", "doc": "<p>Convert date to day of month (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.weekofyear", "modulename": "data_algebra.expr_rep", "qualname": "Term.weekofyear", "type": "function", "doc": "<p>Convert date to week of year (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.month", "modulename": "data_algebra.expr_rep", "qualname": "Term.month", "type": "function", "doc": "<p>Convert date to month (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.quarter", "modulename": "data_algebra.expr_rep", "qualname": "Term.quarter", "type": "function", "doc": "<p>Convert date to quarter (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.year", "modulename": "data_algebra.expr_rep", "qualname": "Term.year", "type": "function", "doc": "<p>Convert date to year (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.timestamp_diff", "modulename": "data_algebra.expr_rep", "qualname": "Term.timestamp_diff", "type": "function", "doc": "<p>Compute difference in timestamps in seconds (vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.date_diff", "modulename": "data_algebra.expr_rep", "qualname": "Term.date_diff", "type": "function", "doc": "<p>Compute difference in dates in days (vectorized).</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.base_Sunday", "modulename": "data_algebra.expr_rep", "qualname": "Term.base_Sunday", "type": "function", "doc": "<p>Compute prior Sunday date from date (self for Sundays) (vectorized).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.kop_expr", "modulename": "data_algebra.expr_rep", "qualname": "kop_expr", "type": "function", "doc": "<p>three argument expression</p>\n", "parameters": ["op", "args", "inline", "method"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value", "modulename": "data_algebra.expr_rep", "qualname": "Value", "type": "class", "doc": "<p>Class for holding constants.</p>\n"}, {"fullname": "data_algebra.expr_rep.Value.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Value.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "Value.is_equal", "type": "function", "doc": "<p>Check if this expression code is the same as another expression.</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.get_views", "modulename": "data_algebra.expr_rep", "qualname": "Value.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "Value.replace_view", "type": "function", "doc": "<p>Move expression to a new view.</p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "Value.evaluate", "type": "function", "doc": "<p>Evaluate expression, taking data from data_frame.</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.to_python", "modulename": "data_algebra.expr_rep", "qualname": "Value.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool, if True put parens around complex expressions that don't already have a grouper.\n:return: PythonText</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm", "type": "class", "doc": "<p>Class to hold a collection.</p>\n"}, {"fullname": "data_algebra.expr_rep.ListTerm.__init__", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.is_equal", "type": "function", "doc": "<p>Check if this expression code is the same as another expression.</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.get_views", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.replace_view", "type": "function", "doc": "<p>Move expression to a new view.</p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.evaluate", "type": "function", "doc": "<p>Evaluate expression, taking data from data_frame.</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.to_python", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool, if True put parens around complex expressions that don't already have a grouper.\n:return: PythonText</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.DictTerm", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm", "type": "class", "doc": "<p>Class for carrying a dictionary or map.</p>\n"}, {"fullname": "data_algebra.expr_rep.DictTerm.__init__", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.DictTerm.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm.is_equal", "type": "function", "doc": "<p>Check if this expression code is the same as another expression.</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.DictTerm.get_views", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.DictTerm.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm.replace_view", "type": "function", "doc": "<p>Move expression to a new view.</p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.DictTerm.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm.evaluate", "type": "function", "doc": "<p>Evaluate expression, taking data from data_frame.</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.DictTerm.to_python", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool, if True put parens around complex expressions that don't already have a grouper.\n:return: PythonText</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.DictTerm.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "DictTerm.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.enc_value", "modulename": "data_algebra.expr_rep", "qualname": "enc_value", "type": "function", "doc": "<p>Encode a value as a PreTerm or derived class.</p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference", "type": "class", "doc": "<p>class to represent referring to a column</p>\n"}, {"fullname": "data_algebra.expr_rep.ColumnReference.__init__", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view", "column_name"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.evaluate", "type": "function", "doc": "<p>Evaluate expression, taking data from data_frame.</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.is_equal", "type": "function", "doc": "<p>Check if this expression code is the same as another expression.</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.get_views", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.replace_view", "type": "function", "doc": "<p>Move expression to a new view.</p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.to_python", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool, if True put parens around complex expressions that don't already have a grouper.\n:return: PythonText</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression", "modulename": "data_algebra.expr_rep", "qualname": "Expression", "type": "class", "doc": "<p>Class for carrying an expression.</p>\n"}, {"fullname": "data_algebra.expr_rep.Expression.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Expression.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "args", "params", "inline", "method"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "Expression.is_equal", "type": "function", "doc": "<p>Check if this expression code is the same as another expression.</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.get_views", "modulename": "data_algebra.expr_rep", "qualname": "Expression.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "Expression.replace_view", "type": "function", "doc": "<p>Move expression to a new view.</p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "Expression.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "Expression.evaluate", "type": "function", "doc": "<p>Evaluate expression, taking data from data_frame.</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.to_python", "modulename": "data_algebra.expr_rep", "qualname": "Expression.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool, if True put parens around complex expressions that don't already have a grouper.\n:return: PythonText</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.connected_components", "modulename": "data_algebra.expr_rep", "qualname": "connected_components", "type": "function", "doc": "<p>Compute connected components.</p>\n", "parameters": ["f", "g"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.standardize_join_type", "modulename": "data_algebra.expr_rep", "qualname": "standardize_join_type", "type": "function", "doc": "<p>Replace join name with standard name.</p>\n", "parameters": ["join_str"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.get_columns_used", "modulename": "data_algebra.expr_rep", "qualname": "get_columns_used", "type": "function", "doc": "<p>Return set of columns used in an expression.</p>\n", "parameters": ["parsed_exprs"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.implies_windowed", "modulename": "data_algebra.expr_rep", "qualname": "implies_windowed", "type": "function", "doc": "<p>Return true if expression implies a windowed calculation is needed.</p>\n", "parameters": ["parsed_exprs"], "funcdef": "def"}, {"fullname": "data_algebra.flow_text", "modulename": "data_algebra.flow_text", "qualname": "", "type": "module", "doc": "<p>Flow text around a margin for presentation.</p>\n"}, {"fullname": "data_algebra.flow_text.flow_text", "modulename": "data_algebra.flow_text", "qualname": "flow_text", "type": "function", "doc": "<p>:param tokens: list or tuple of strings\n:param align_right: integer, right alignment margin\n:param sep_width: integer, size of inline separator\n:return: list of lists of strings flowing the text to the margin</p>\n", "parameters": ["tokens", "align_right", "sep_width"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql", "modulename": "data_algebra.near_sql", "qualname": "", "type": "module", "doc": "<p>Representation for operations that are nearly translated into SQL.</p>\n"}, {"fullname": "data_algebra.near_sql.SQLWithList", "modulename": "data_algebra.near_sql", "qualname": "SQLWithList", "type": "class", "doc": "<p>Carry an ordered sequence of SQL steps for use with a SQL WITH statement.</p>\n"}, {"fullname": "data_algebra.near_sql.SQLWithList.__init__", "modulename": "data_algebra.near_sql", "qualname": "SQLWithList.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "last_step", "previous_steps"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL", "modulename": "data_algebra.near_sql", "qualname": "NearSQL", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQL.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "query_name", "quoted_query_name", "is_table", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.is_table", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.is_table", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.near_sql.NearSQL.annotation", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.annotation", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.near_sql.NearSQL.to_bound_near_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_bound_near_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer", "type": "class", "doc": "<p>NearSQL with bound in columns, force_sql, and constants decisions</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.convert_subsql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.convert_subsql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.to_with_form_stub", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.to_with_form_stub", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "query_name", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "query_name", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLTable", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLTable.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "table_name", "quoted_table_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLTable.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "query_name", "quoted_query_name", "sub_sql", "suffix", "annotation", "mergeable", "declared_term_dependencies"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "query_name", "quoted_query_name", "sub_sql1", "joiner", "sub_sql2", "suffix", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "prefix", "query_name", "quoted_query_name", "sub_sql", "suffix", "annotation", "add_select"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container", "modulename": "data_algebra.op_container", "qualname": "", "type": "module", "doc": "<p>Redirecting container.</p>\n"}, {"fullname": "data_algebra.op_container.OpC", "modulename": "data_algebra.op_container", "qualname": "OpC", "type": "class", "doc": "<p>Container that redirects to another to non-quoted notation.</p>\n"}, {"fullname": "data_algebra.op_container.OpC.__init__", "modulename": "data_algebra.op_container", "qualname": "OpC.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.set", "modulename": "data_algebra.op_container", "qualname": "OpC.set", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.get_ops", "modulename": "data_algebra.op_container", "qualname": "OpC.get_ops", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.ex", "modulename": "data_algebra.op_container", "qualname": "OpC.ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["self", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.transform", "modulename": "data_algebra.op_container", "qualname": "OpC.transform", "type": "function", "doc": "<p>apply self to data frame X, may or may not commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model: implementation to use\n:param narrow: logical, if True don't copy unexpected columns\n:param check_incoming_data_constraints: logical, if True check incoming data meets constraints\n:return: transformed data frame</p>\n", "parameters": ["self", "X", "data_model", "narrow", "check_incoming_data_constraints"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.act_on", "modulename": "data_algebra.op_container", "qualname": "OpC.act_on", "type": "function", "doc": "<p>apply self to data frame X, must commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.apply_to", "modulename": "data_algebra.op_container", "qualname": "OpC.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.eval", "modulename": "data_algebra.op_container", "qualname": "OpC.eval", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames.</p>\n\n<p>:param data_map: map from table names to data frames\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:return: table result</p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.get_tables", "modulename": "data_algebra.op_container", "qualname": "OpC.get_tables", "type": "function", "doc": "<p>Get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.add", "modulename": "data_algebra.op_container", "qualname": "OpC.add", "type": "function", "doc": "<p>other.apply_to(self)</p>\n\n<p>:param other:\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.columns_produced", "modulename": "data_algebra.op_container", "qualname": "OpC.columns_produced", "type": "function", "doc": "<p>Return list of columns produced by pipeline.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.to_near_sql_implementation_", "modulename": "data_algebra.op_container", "qualname": "OpC.to_near_sql_implementation_", "type": "function", "doc": "<p>Convert to NearSQL as a step in converting to a SQL string. Internal method.</p>\n\n<p>:param db_model: database model\n:param using: optional column restriction\n:param temp_id_source: temporary id source.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.extend_parsed_", "modulename": "data_algebra.op_container", "qualname": "OpC.extend_parsed_", "type": "function", "doc": "<p>Add new derived columns, can replace existing columns for parsed operations. Internal method.</p>\n\n<p>:param parsed_ops: dictionary of calculations to perform.\n:param partition_by: optional window partition specification.\n:param order_by: optional window ordering specification.\n:param reverse: optional order reversal specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.extend", "modulename": "data_algebra.op_container", "qualname": "OpC.extend", "type": "function", "doc": "<p>Add new derived columns, can replace existing columns.</p>\n\n<p>:param ops: dictionary of calculations to perform.\n:param partition_by: optional window partition specification.\n:param order_by: optional window ordering specification.\n:param reverse: optional order reversal specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.project_parsed_", "modulename": "data_algebra.op_container", "qualname": "OpC.project_parsed_", "type": "function", "doc": "<p>Compute projection, or grouped calculation for parsed ops. Internal method.</p>\n\n<p>:param parsed_ops: dictionary of calculations to perform, can be empty.\n:param group_by: optional group key(s) specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.project", "modulename": "data_algebra.op_container", "qualname": "OpC.project", "type": "function", "doc": "<p>Compute projection, or grouped calculation.</p>\n\n<p>:param ops: dictionary of calculations to perform, can be empty.\n:param group_by: optional group key(s) specification.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.natural_join", "modulename": "data_algebra.op_container", "qualname": "OpC.natural_join", "type": "function", "doc": "<p>Join self (left) results with b (right).</p>\n\n<p>:param b: second or right table to join to.\n:param by: list of join key column names.\n:param jointype: name of join type.\n:param check_all_common_keys_in_by: if True, raise if any non-key columns are common to tables.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.concat_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.concat_rows", "type": "function", "doc": "<p>Union or concatenate rows of self with rows of b.</p>\n\n<p>:param b: table with rows to add.\n:param id_column: optional name for new source identification column.\n:param a_name: source annotation to use for self/a.\n:param b_name: source annotation to use for b.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_rows_parsed_", "modulename": "data_algebra.op_container", "qualname": "OpC.select_rows_parsed_", "type": "function", "doc": "<p>Select rows matching parsed expr criteria. Internal method.</p>\n\n<p>:param parsed_expr: logical expression specifying desired rows.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.select_rows", "type": "function", "doc": "<p>Select rows matching expr criteria.</p>\n\n<p>:param expr: logical expression specifying desired rows.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.drop_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.drop_columns", "type": "function", "doc": "<p>Remove columns from result.</p>\n\n<p>:param column_deletions: list of columns to remove.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.select_columns", "type": "function", "doc": "<p>Narrow to columns in result.</p>\n\n<p>:param columns: list of columns to keep.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.rename_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.rename_columns", "type": "function", "doc": "<p>Rename columns.</p>\n\n<p>:param column_remapping: dictionary mapping new column names to old column sources (same\n                         direction as extend).\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.order_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.order_rows", "type": "function", "doc": "<p>Order rows by column set.</p>\n\n<p>:param columns: columns to order by.\n:param reverse: optional columns to reverse order.\n:param limit: optional row limit to impose on result.\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.convert_records", "modulename": "data_algebra.op_container", "qualname": "OpC.convert_records", "type": "function", "doc": "<p>Apply a record mapping taking blocks_in to blocks_out structures.</p>\n\n<p>:param record_map: data_algebra.cdata.RecordMap transform specification\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.map_records", "modulename": "data_algebra.op_container", "qualname": "OpC.map_records", "type": "function", "doc": "<p>Apply a record mapping taking blocks_in to blocks_out structures.</p>\n\n<p>:param blocks_in: Optional incoming record specification\n:param blocks_out: Optional incoming record specification\n:return: compose operator directed acyclic graph</p>\n", "parameters": ["self", "blocks_in", "blocks_out"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.fit", "modulename": "data_algebra.op_container", "qualname": "OpC.fit", "type": "function", "doc": "<p>sklearn interface, fit() is a noop</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.fit_transform", "modulename": "data_algebra.op_container", "qualname": "OpC.fit_transform", "type": "function", "doc": "<p>sklearn interface, fit() is a noop</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.get_feature_names", "modulename": "data_algebra.op_container", "qualname": "OpC.get_feature_names", "type": "function", "doc": "<p>sklearn interface, return columns</p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.Pipeline", "modulename": "data_algebra.op_container", "qualname": "Pipeline", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.op_container.Pipeline.__init__", "modulename": "data_algebra.op_container", "qualname": "Pipeline.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base", "modulename": "data_algebra.pandas_base", "qualname": "", "type": "module", "doc": "<p>Base class for adapters for Pandas-like APIs</p>\n"}, {"fullname": "data_algebra.pandas_base.populate_impl_map", "modulename": "data_algebra.pandas_base", "qualname": "populate_impl_map", "type": "function", "doc": "<p>Map symbols to implementations.</p>\n", "parameters": ["data_model"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase", "type": "class", "doc": "<p>Base class for implementing the data algebra on pandas-like APIs</p>\n"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.__init__", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pd", "presentation_model_name"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.data_frame", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.data_frame", "type": "function", "doc": "<p>Build a new emtpy data frame.</p>\n\n<p>:param arg\" optional argument passed to constructor.\n:return: data frame</p>\n", "parameters": ["self", "arg"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.is_appropriate_data_instance", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.is_appropriate_data_instance", "type": "function", "doc": "<p>Check if df is our type of data frame.</p>\n", "parameters": ["self", "df"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.can_convert_col_to_numeric", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.can_convert_col_to_numeric", "type": "function", "doc": "<p>Return True if column or value can be converted to numeric type.</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.to_numeric", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.to_numeric", "type": "function", "doc": "<p>Convert column to numeric.</p>\n", "parameters": ["self", "x", "errors"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.isnull", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.isnull", "type": "function", "doc": "<p>Return vector indicating which entries are null (vectorized).</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.bad_column_positions", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.bad_column_positions", "type": "function", "doc": "<p>Return vector indicating which entries are bad (null or nan) (vectorized).</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.table_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.table_step", "type": "function", "doc": "<p>Return data frame from table description and data_map.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.columns_to_frame_", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.columns_to_frame_", "type": "function", "doc": "<p>Convert a dictionary of column names to series-like objects and scalars into a Pandas data frame.</p>\n\n<p>:param cols: dictionary mapping column names to columns\n:param target_rows: number of rows we are shooting for\n:return: Pandas data frame.</p>\n", "parameters": ["self", "cols", "target_rows"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.add_data_frame_columns_to_data_frame_", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.add_data_frame_columns_to_data_frame_", "type": "function", "doc": "<p>Add columns from transient_new_frame to res. Res may be altered, and either of res or\ntransient_new_frame may be returned.</p>\n", "parameters": ["self", "res", "transient_new_frame"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.eval", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.eval", "type": "function", "doc": "<p>Implementation of Pandas evaluation of operators</p>\n\n<p>:param op: ViewRepresentation to evaluate\n:param data_map: dictionary mapping table and view names to data frames\n:param narrow: if True narrow results to only columns anticipated\n:return: data frame result</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.extend_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.extend_step", "type": "function", "doc": "<p>Execute an extend step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.project_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.project_step", "type": "function", "doc": "<p>Execute a project step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.select_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.select_rows_step", "type": "function", "doc": "<p>Execute a select rows step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.select_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.select_columns_step", "type": "function", "doc": "<p>Execute a select columns step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.drop_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.drop_columns_step", "type": "function", "doc": "<p>Execute a drop columns step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.order_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.order_rows_step", "type": "function", "doc": "<p>Execute an order rows step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.rename_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.rename_columns_step", "type": "function", "doc": "<p>Execute a rename columns step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.standardize_join_code_", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.standardize_join_code_", "type": "function", "doc": "<p>Map join names to Pandas names. Internal method.</p>\n", "parameters": ["self", "jointype"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.natural_join_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.natural_join_step", "type": "function", "doc": "<p>Execute a natural join step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.concat_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.concat_rows_step", "type": "function", "doc": "<p>Execute a concat rows step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.convert_records_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.convert_records_step", "type": "function", "doc": "<p>Execute record conversion step, returning a data frame.</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_model", "modulename": "data_algebra.pandas_model", "qualname": "", "type": "module", "doc": "<p>Adapter for Pandas API.</p>\n"}, {"fullname": "data_algebra.pandas_model.PandasModel", "modulename": "data_algebra.pandas_model", "qualname": "PandasModel", "type": "class", "doc": "<p>Realize the data algebra over pandas.</p>\n"}, {"fullname": "data_algebra.pandas_model.PandasModel.__init__", "modulename": "data_algebra.pandas_model", "qualname": "PandasModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.parse_by_lark", "modulename": "data_algebra.parse_by_lark", "qualname": "", "type": "module", "doc": "<p>Use Lark to parse a near-Python expression grammar.</p>\n"}, {"fullname": "data_algebra.parse_by_lark.parse_by_lark", "modulename": "data_algebra.parse_by_lark", "qualname": "parse_by_lark", "type": "function", "doc": "<p>Parse an expression in terms of data views and values.</p>\n\n<p>:param source_str: string to parse\n:param data_def: dictionary of data_algebra.expr_rep.ColumnReference\n:return: data_algebra.expr_rep.Term</p>\n", "parameters": ["source_str", "data_def"], "funcdef": "def"}, {"fullname": "data_algebra.python3_lark", "modulename": "data_algebra.python3_lark", "qualname": "", "type": "module", "doc": "<p>Modified Lark grammar for Python-like expressions.</p>\n\n<p>https://github.com/lark-parser/lark/blob/master/examples/advanced/python3.lark\nCopyright 2017 Erez Shinan\nLicence: https://github.com/lark-parser/lark/blob/master/LICENSE (MIT)</p>\n"}, {"fullname": "data_algebra.test_util", "modulename": "data_algebra.test_util", "qualname": "", "type": "module", "doc": "<p>Utils that help with testing. This module is allowed to import many other modules.</p>\n"}, {"fullname": "data_algebra.test_util.re_parse", "modulename": "data_algebra.test_util", "qualname": "re_parse", "type": "function", "doc": "<p>Return copy of object made by dumpint to string via repr() and then evaluating that string.</p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.formats_to_self", "modulename": "data_algebra.test_util", "qualname": "formats_to_self", "type": "function", "doc": "<p>Check a operator dag formats and parses back to itself.\nCan raise exceptions. Also checks pickling.</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:return: logical, True if formats and evals back to self</p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.equivalent_frames", "modulename": "data_algebra.test_util", "qualname": "equivalent_frames", "type": "function", "doc": "<p>return False if the frames are equivalent (up to column re-ordering and possible row-reordering).\nIgnores indexing. None and nan are considered equivalent in numeric contexts.</p>\n", "parameters": ["a", "b", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.hash_data_frame", "modulename": "data_algebra.test_util", "qualname": "hash_data_frame", "type": "function", "doc": "<p>Get a hash code representing a data frame.</p>\n\n<p>:param d: data frame\n:return: hash code as a string</p>\n", "parameters": ["d"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.check_transform_on_handles", "modulename": "data_algebra.test_util", "qualname": "check_transform_on_handles", "type": "function", "doc": "<p>Test an operator dag produces the expected result, and parses correctly.\nAsserts if there are issues</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:param data: pd.DataFrame or map of strings to pd.DataFrame\n:param expect: pd.DataFrame\n:param db_handles:  list of database handles to use in testing\n:param float_tol: passed to equivalent_frames()\n:param check_column_order: passed to equivalent_frames()\n:param cols_case_sensitive: passed to equivalent_frames()\n:param check_row_order: passed to equivalent_frames()\n:param check_parse: if True check expression parses/formats to self\n:param local_data_model: optional alternate evaluation model\n:param empty_produces_empty: logical, if true assume emtpy inputs should produce empty output\n:return: None, assert if there is an issue</p>\n", "parameters": ["ops", "data", "expect", "db_handles", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "check_parse", "local_data_model", "empty_produces_empty"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.get_test_dbs", "modulename": "data_algebra.test_util", "qualname": "get_test_dbs", "type": "function", "doc": "<p>handles connected to databases for testing.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.test_util.check_transform", "modulename": "data_algebra.test_util", "qualname": "check_transform", "type": "function", "doc": "<p>Test an operator dag produces the expected result, and parses correctly.\nAssert if there are issues.</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:param data: pd.DataFrame or map of strings to pd.DataFrame\n:param expect: pd.DataFrame\n:param float_tol: passed to equivalent_frames()\n:param check_column_order: passed to equivalent_frames()\n:param cols_case_sensitive: passed to equivalent_frames()\n:param check_row_order: passed to equivalent_frames()\n:param check_parse: if True check expression parses/formats to self\n:param models_to_skip: None or set of model names to skip testing\n:param empty_produces_empty: logical, if true assume emtpy inputs should produce empty output\n:return: nothing</p>\n", "parameters": ["ops", "data", "expect", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "check_parse", "models_to_skip", "empty_produces_empty"], "funcdef": "def"}, {"fullname": "data_algebra.util", "modulename": "data_algebra.util", "qualname": "", "type": "module", "doc": "<p>Basic utilities. Not allowed to import many other modules.</p>\n"}, {"fullname": "data_algebra.util.pandas_to_example_str", "modulename": "data_algebra.util", "qualname": "pandas_to_example_str", "type": "function", "doc": "<p>Convert data frame to a Python source code string.</p>\n\n<p>:param obj: data frame to convert.\n:param local_data_model: data model to use.\n:return: Python source code representation of obj.</p>\n", "parameters": ["obj", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.util.table_is_keyed_by_columns", "modulename": "data_algebra.util", "qualname": "table_is_keyed_by_columns", "type": "function", "doc": "<p>Check if a table is keyed by a given list of column names.</p>\n\n<p>:param table: pandas DataFrame\n:param column_names: list of column names\n:return: True if rows are uniquely keyed by values in named columns</p>\n", "parameters": ["table", "column_names"], "funcdef": "def"}, {"fullname": "data_algebra.util.map_type_to_canonical", "modulename": "data_algebra.util", "qualname": "map_type_to_canonical", "type": "function", "doc": "<p>Map type to a smaller set of considered equivalent types.</p>\n\n<p>:param v: type to map\n:return: type</p>\n", "parameters": ["v"], "funcdef": "def"}, {"fullname": "data_algebra.util.guess_carried_scalar_type", "modulename": "data_algebra.util", "qualname": "guess_carried_scalar_type", "type": "function", "doc": "<p>Guess the type of a column or scalar.</p>\n\n<p>:param col: column or scalar to inspect\n:return: type of first non-None entry, if any , else type(None)</p>\n", "parameters": ["col"], "funcdef": "def"}, {"fullname": "data_algebra.util.guess_column_types", "modulename": "data_algebra.util", "qualname": "guess_column_types", "type": "function", "doc": "<p>Guess column types as type of first non-missing value.\nWill not return series types, as some pandas data frames with non-trivial indexing report this type.</p>\n\n<p>:param d: pandas.DataFrame\n:param columns: list of columns to check, if None all columns are checked\n:return: map of column names to guessed types, empty dict if any column guess fails</p>\n", "parameters": ["d", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.util.compatible_types", "modulename": "data_algebra.util", "qualname": "compatible_types", "type": "function", "doc": "<p>Check if a set of types are all considered equivalent.</p>\n\n<p>:param types_seen: collection of types seen\n:return: True if types are all compatible, else False.</p>\n", "parameters": ["types_seen"], "funcdef": "def"}, {"fullname": "data_algebra.util.check_columns_appear_compatible", "modulename": "data_algebra.util", "qualname": "check_columns_appear_compatible", "type": "function", "doc": "<p>Check if columns have compatible types</p>\n\n<p>:param d_left: pandas dataframe to check\n:param d_right: pandas dataframe to check\n:param columns: columns to check, None means check all columns\n:return: None if compatible, else dictionary of mismatches</p>\n", "parameters": ["d_left", "d_right", "columns"], "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();
[{"fullname": "data_algebra", "modulename": "data_algebra", "qualname": "", "type": "module", "doc": "<p><code>data_algebra</code><a href=\"https://github.com/WinVector/data_algebra\">https://github.com/WinVector/data_algebra</a> is a piped data wrangling system\nbased on Codd's relational algebra and experience working with dplyr at scale.  The primary \npurpose of the package is to support an easy to compose and maintain grammar of data processing\nsteps that in turn can be used to generate database specific SQL.  The package also implements\nthe same transforms for Pandas DataFrames. </p>\n\n<p>This package is still under initial development, so some parts are not yet implemented or tested, and APIs\nare subject to change.</p>\n\n<p>Mature, production ready <code>R</code><a href=\"https://www.r-project.org\">https://www.r-project.org</a> versions of the system are available as \nthe <code>rquery</code><a href=\"https://github.com/WinVector/rquery\">https://github.com/WinVector/rquery</a> and <code>rqdatatable</code><a href=\"https://github.com/WinVector/rqdatatable\">https://github.com/WinVector/rqdatatable</a> packages.</p>\n"}, {"fullname": "data_algebra.BigQuery", "modulename": "data_algebra.BigQuery", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.BigQuery.BigQueryModel", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel", "type": "class", "doc": "<p>A model of how SQL should be generated for BigQuery\nconnection should be google.cloud.bigquery.client.Client</p>\n"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.__init__", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_prefix"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.quote_table_name", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.quote_table_name", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_description"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.execute", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.execute", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.read_query", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.insert_table", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.db_handle", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.db_handle", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.__init__", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.describe_bq_table", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.describe_bq_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_catalog", "table_schema", "table_name", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.query_to_csv", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.query_to_csv", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q", "res_name"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.example_handle", "modulename": "data_algebra.BigQuery", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.\nNote: binds in a data_catalog and data schema prefix. So this handle is specific\nto one database.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.MySQL", "modulename": "data_algebra.MySQL", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.MySQL.MySQLModel", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for MySQL.\nAssuming we are using a sqlalhemy engine as our connection</p>\n"}, {"fullname": "data_algebra.MySQL.MySQLModel.__init__", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.MySQL.MySQLModel.quote_identifier", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel.quote_identifier", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "identifier"], "funcdef": "def"}, {"fullname": "data_algebra.MySQL.example_handle", "modulename": "data_algebra.MySQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet", "modulename": "data_algebra.OrderedSet", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet", "type": "class", "doc": "<p>Dictionary that remembers insertion order</p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.__init__", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.update", "type": "function", "doc": "<p>D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.add", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.add", "type": "function", "doc": "<p>Add an element.</p>\n", "parameters": ["self", "elem"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.discard", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.discard", "type": "function", "doc": "<p>Remove an element.  Do not raise an exception if absent.</p>\n", "parameters": ["self", "elem"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.difference", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.difference", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.difference_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.difference_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.intersection", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.intersection", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.intersection_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.intersection_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.issubset", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.issubset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.issuperset", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.issuperset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.symmetric_difference", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.symmetric_difference", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.symmetric_difference_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.symmetric_difference_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.union", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.union", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args"], "funcdef": "def"}, {"fullname": "data_algebra.PostgreSQL", "modulename": "data_algebra.PostgreSQL", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.PostgreSQL.PostgreSQLModel", "modulename": "data_algebra.PostgreSQL", "qualname": "PostgreSQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for PostgreSQL.\nAssuming we are using a sqlalhemy engine as our connection</p>\n"}, {"fullname": "data_algebra.PostgreSQL.PostgreSQLModel.__init__", "modulename": "data_algebra.PostgreSQL", "qualname": "PostgreSQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.PostgreSQL.example_handle", "modulename": "data_algebra.PostgreSQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.SQLite", "modulename": "data_algebra.SQLite", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SQLite.MedianAgg", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SQLite.MedianAgg.__init__", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.MedianAgg.step", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.MedianAgg.finalize", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.finalize", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel", "type": "class", "doc": "<p>A model of how SQL should be generated for SQLite</p>\n"}, {"fullname": "data_algebra.SQLite.SQLiteModel.__init__", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.prepare_connection", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.prepare_connection", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.insert_table", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.insert_table", "type": "function", "doc": "<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.example_handle", "modulename": "data_algebra.SQLite", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL", "modulename": "data_algebra.SparkSQL", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkConnection", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkConnection.__init__", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "spark_context", "spark_session"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkConnection.close", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection.close", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for SparkSQL.</p>\n\n<p>Known issue: doesn't coalesce NaN</p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.__init__", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.execute", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.execute", "type": "function", "doc": "<p>:param conn: database connectionex\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.read_query", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.insert_table", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.example_handle", "modulename": "data_algebra.SparkSQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.arrow", "modulename": "data_algebra.arrow", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.arrow.Arrow", "modulename": "data_algebra.arrow", "qualname": "Arrow", "type": "class", "doc": "<p>Arrow from category theory: see Steve Awody, \"Category Theory, 2nd Edition\", Oxford Univ. Press, 2010 pg. 4.</p>\n"}, {"fullname": "data_algebra.arrow.Arrow.__init__", "modulename": "data_algebra.arrow", "qualname": "Arrow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.dom", "modulename": "data_algebra.arrow", "qualname": "Arrow.dom", "type": "function", "doc": "<p>return domain, object at base of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.cod", "modulename": "data_algebra.arrow", "qualname": "Arrow.cod", "type": "function", "doc": "<p>return co-domain, object at head of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.apply_to", "modulename": "data_algebra.arrow", "qualname": "Arrow.apply_to", "type": "function", "doc": "<p>apply_to b, compose arrows (right to left)</p>\n", "parameters": ["self", "b"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.act_on", "modulename": "data_algebra.arrow", "qualname": "Arrow.act_on", "type": "function", "doc": "<p>act on X, must associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.transform", "type": "function", "doc": "<p>transform X, may or may not associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.fit", "modulename": "data_algebra.arrow", "qualname": "Arrow.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.fit_transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.get_feature_names", "modulename": "data_algebra.arrow", "qualname": "Arrow.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.get_params", "modulename": "data_algebra.arrow", "qualname": "Arrow.get_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.set_params", "modulename": "data_algebra.arrow", "qualname": "Arrow.set_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.inverse_transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.inverse_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow", "type": "class", "doc": "<p>Represent a dag of operators as a categorical arrow.</p>\n"}, {"fullname": "data_algebra.arrow.DataOpArrow.__init__", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pipeline", "free_table_key", "strict", "forbidden_to_produce"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.get_feature_names", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.apply_to", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.apply_to", "type": "function", "doc": "<p>replace self input table with b</p>\n", "parameters": ["self", "b"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.act_on", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.act_on", "type": "function", "doc": "<p>act on X, must associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.learn_types", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.learn_types", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_in", "data_out"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.fit", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.fit", "type": "function", "doc": "<p>Learn input and output types from example, and return self</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.fit_transform", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.fit_transform", "type": "function", "doc": "<p>Learn input and output types from example, and return transform.</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.dom", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.dom", "type": "function", "doc": "<p>return domain, object at base of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.dom_as_table", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.dom_as_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.cod", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.cod", "type": "function", "doc": "<p>return co-domain, object at head of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.cod_as_table", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.cod_as_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.required_columns", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.required_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.forbidden_columns", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.forbidden_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.format_end_description", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.format_end_description", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "required_cols", "col_types", "forbidden_cols", "align_right", "sep_width"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.fmt_as_arrow", "modulename": "data_algebra.arrow", "qualname": "fmt_as_arrow", "type": "function", "doc": "<p></p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.cdata", "modulename": "data_algebra.cdata", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.cdata.RecordSpecification", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.cdata.RecordSpecification.__init__", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.__init__", "type": "function", "doc": "<p>Class to represent a multi-row data record.</p>\n\n<p>:param control_table: data.frame describing record layout\n:param record_keys: array of record key column names\n:param control_table_keys: array of control_table key column names\n:param strict: logical, if True more checks on transform\n:param local_data_model: data.frame data model</p>\n", "parameters": ["self", "control_table", "record_keys", "control_table_keys", "strict", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.row_version", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.row_version", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "include_record_keys"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.fmt", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.fmt", "type": "function", "doc": "<p>Prepare for printing</p>\n\n<p>:return: multi line string representation.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.map_to_rows", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.map_to_rows", "type": "function", "doc": "<p>Build a RecordMap mapping this RecordSpecification to rowrecs</p>\n\n<p>:param strict:\n:return: RecordMap</p>\n", "parameters": ["self", "strict"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.map_from_rows", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.map_from_rows", "type": "function", "doc": "<p>Build a RecordMap mapping this RecordSpecification from rowrecs</p>\n\n<p>:param strict:\n:return: RecordMap</p>\n", "parameters": ["self", "strict"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.blocks_to_rowrecs", "modulename": "data_algebra.cdata", "qualname": "blocks_to_rowrecs", "type": "function", "doc": "<p></p>\n", "parameters": ["data", "blocks_in", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.rowrecs_to_blocks", "modulename": "data_algebra.cdata", "qualname": "rowrecs_to_blocks", "type": "function", "doc": "<p></p>\n", "parameters": ["data", "blocks_out", "check_blocks_out_keying", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap", "modulename": "data_algebra.cdata", "qualname": "RecordMap", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.cdata.RecordMap.__init__", "modulename": "data_algebra.cdata", "qualname": "RecordMap.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "blocks_in", "blocks_out", "strict"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.record_keys", "modulename": "data_algebra.cdata", "qualname": "RecordMap.record_keys", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.example_input", "modulename": "data_algebra.cdata", "qualname": "RecordMap.example_input", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "check_blocks_out_keying", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.compose", "modulename": "data_algebra.cdata", "qualname": "RecordMap.compose", "type": "function", "doc": "<p>Experimental method to compose transforms\n(self.compose(other)).transform(data) == self.transform(other.transform(data))</p>\n\n<p>:param other: another data_algebra.cdata.RecordMap\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.inverse", "modulename": "data_algebra.cdata", "qualname": "RecordMap.inverse", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fmt", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fmt", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fit", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fit_transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.get_feature_names", "modulename": "data_algebra.cdata", "qualname": "RecordMap.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.get_params", "modulename": "data_algebra.cdata", "qualname": "RecordMap.get_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.set_params", "modulename": "data_algebra.cdata", "qualname": "RecordMap.set_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.inverse_transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.inverse_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.pivot_blocks_to_rowrecs", "modulename": "data_algebra.cdata", "qualname": "pivot_blocks_to_rowrecs", "type": "function", "doc": "<p>Build a block records to row records map.</p>\n\n<p>:param attribute_key_column: column to identify record attribute keys\n:param attribute_value_column: column for record attribute values\n:param record_keys: names of key columns identifying row record blocks\n:param record_value_columns: names of columns to take row record values from\n:param strict: logical, if True more checks on transform\n:param local_data_model: data.frame data model\n:return: RecordMap</p>\n", "parameters": ["attribute_key_column", "attribute_value_column", "record_keys", "record_value_columns", "strict", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.pivot_rowrecs_to_blocks", "modulename": "data_algebra.cdata", "qualname": "pivot_rowrecs_to_blocks", "type": "function", "doc": "<p>Build a row records to block records map.</p>\n\n<p>:param attribute_key_column: column to identify record attribute keys\n:param attribute_value_column: column for record attribute values\n:param record_keys: names of key columns identifying row record blocks\n:param record_value_columns: names of columns to take row record values from\n:param strict: logical, if True more checks on transform\n:param local_data_model: data.frame data model\n:return: RecordMap</p>\n", "parameters": ["attribute_key_column", "attribute_value_column", "record_keys", "record_value_columns", "strict", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.connected_components", "modulename": "data_algebra.connected_components", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.connected_components.Component", "modulename": "data_algebra.connected_components", "qualname": "Component", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.connected_components.Component.__init__", "modulename": "data_algebra.connected_components", "qualname": "Component.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "item"], "funcdef": "def"}, {"fullname": "data_algebra.connected_components.connected_components", "modulename": "data_algebra.connected_components", "qualname": "connected_components", "type": "function", "doc": "<p>Compute connected components of undirected edges (f[i], g[i]).</p>\n\n<p>For the return value we are using the\ncategory formulation that these are the co-equalizer of f and g,\nmeaning it is a finest partition such that return[f[i]] = return[g[i]]\nfor all i.  We pick the least item in each component as the representation.\nThis is just a long way of saying: as each side of an edge is in the same\ncomponent, we return the assignment by labeling the edges by components\n(instead of the vertices).</p>\n\n<p>Not as fast as union/find but fast.</p>\n\n<p>f = [1, 4, 6, 2, 1]\ng = [2, 5, 7, 3, 7]\nres = connected_components(f, g)\nprint(res)</p>\n\n<p>:param f: list or vector of hashable/comparable items of length n\n:param g: list or vector of hashable/comparable items of length n\n:return: list of assignments of length n (map both f and g to same values.</p>\n", "parameters": ["f", "g"], "funcdef": "def"}, {"fullname": "data_algebra.data_model", "modulename": "data_algebra.data_model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_model.negate_or_subtract", "modulename": "data_algebra.data_model", "qualname": "negate_or_subtract", "type": "function", "doc": "<p></p>\n", "parameters": ["args"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.populate_impl_map", "modulename": "data_algebra.data_model", "qualname": "populate_impl_map", "type": "function", "doc": "<p></p>\n", "parameters": ["data_model"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel", "modulename": "data_algebra.data_model", "qualname": "DataModel", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "data_algebra.data_model.DataModel.__init__", "modulename": "data_algebra.data_model", "qualname": "DataModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "presentation_model_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.data_frame", "modulename": "data_algebra.data_model", "qualname": "DataModel.data_frame", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "arg"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.is_appropriate_data_instance", "modulename": "data_algebra.data_model", "qualname": "DataModel.is_appropriate_data_instance", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "df"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.can_convert_col_to_numeric", "modulename": "data_algebra.data_model", "qualname": "DataModel.can_convert_col_to_numeric", "type": "function", "doc": "<p>check if non-empty vector can convert to numeric</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.to_numeric", "modulename": "data_algebra.data_model", "qualname": "DataModel.to_numeric", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x", "errors"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.isnull", "modulename": "data_algebra.data_model", "qualname": "DataModel.isnull", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.bad_column_positions", "modulename": "data_algebra.data_model", "qualname": "DataModel.bad_column_positions", "type": "function", "doc": "<p>for numeric vector x, return logical vector of positions that are null, NaN, infinite</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.table_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.table_step", "type": "function", "doc": "<p>Represents a data input.</p>\n\n<p>:param op:\n:param data_map:\n:param narrow:\n:return:</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.extend_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.extend_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.columns_to_frame", "modulename": "data_algebra.data_model", "qualname": "DataModel.columns_to_frame", "type": "function", "doc": "<p>:param cols: dictionary mapping column names to columns\n:return:</p>\n", "parameters": ["self", "cols"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.project_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.project_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.select_rows_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.select_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.select_columns_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.select_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.drop_columns_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.drop_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.order_rows_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.order_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.rename_columns_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.rename_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.natural_join_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.natural_join_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.concat_rows_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.concat_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.convert_records_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.convert_records_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops", "modulename": "data_algebra.data_ops", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.pretty_format_python", "modulename": "data_algebra.data_ops", "qualname": "pretty_format_python", "type": "function", "doc": "<p></p>\n", "parameters": ["python_str", "black_mode"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.__init__", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_names", "sources", "node_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.column_names", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.column_names", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.column_set", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.column_set", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.sources", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.sources", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.merged_rep_id", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.merged_rep_id", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.get_tables", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.get_tables", "type": "function", "doc": "<p>Get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_produced", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_produced", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_used", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_used", "type": "function", "doc": "<p>Determine which columns are used from source tables.</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_python", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_python", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "pretty", "black_mode"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_sql", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "pretty", "annotate", "encoding", "sqlparse_options", "temp_tables", "use_with"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.check_constraints", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.check_constraints", "type": "function", "doc": "<p>Check tables supplied meet data consistency constraints.</p>\n\n<p>data_model: dictionairy of column name lists.</p>\n", "parameters": ["self", "data_model", "strict"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.eval", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.eval", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames.\n:param data_map: map from table names to data frames\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow logical, if True don't copy unexpected columns\n:return:</p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.transform", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.transform", "type": "function", "doc": "<p>apply self to data frame X, may or may not commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:param narrow logical, if True don't copy unexpected columns\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.is_trivial_when_intermediate", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.is_trivial_when_intermediate", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.as_table_description", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.as_table_description", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name", "qualifiers", "column_types"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.extend_parsed", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.extend_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.extend", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.extend", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.project_parsed", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.project_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.project", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.natural_join", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.natural_join", "type": "function", "doc": "<p>:param b: right table\n:param by: list of keys to join by\n:param jointype: one of 'INNER', 'LEFT', 'RIGHT', 'OUTER', 'FULL', 'CROSS' (case insensitive)\n:return: ops describing join</p>\n", "parameters": ["self", "b", "by", "jointype"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.concat_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.concat_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_rows_parsed", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_rows_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.drop_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.drop_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.rename_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.rename_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.order_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.order_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.convert_records", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.convert_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_map", "temp_namer"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription", "modulename": "data_algebra.data_ops", "qualname": "TableDescription", "type": "class", "doc": "<p>Describe columns, and qualifiers, of a table.</p>\n\n<p>Example:\n    from data_algebra.data_ops import *\n    d = TableDescription('d', ['x', 'y'])\n    print(d)</p>\n"}, {"fullname": "data_algebra.data_ops.TableDescription.__init__", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name", "column_names", "qualifiers", "sql_meta", "column_types", "head", "limit_was"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.table_name", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.table_name", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.TableDescription.column_names", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.column_names", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.TableDescription.qualifiers", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.qualifiers", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.TableDescription.key", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.key", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.TableDescription.same_table", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.same_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.merged_rep_id", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.merged_rep_id", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.apply_to", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.get_tables", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.get_tables", "type": "function", "doc": "<p>get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.describe_table", "modulename": "data_algebra.data_ops", "qualname": "describe_table", "type": "function", "doc": "<p></p>\n", "parameters": ["d", "table_name", "qualifiers", "sql_meta", "column_types", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ExtendNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.check_extend_window_fns", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.check_extend_window_fns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ProjectNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "ops"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.expr", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.expr", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.decision_columns", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.decision_columns", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.column_selection", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.column_selection", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.column_deletions", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.column_deletions", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.order_columns", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.order_columns", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.reverse", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.reverse", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.is_trivial_when_intermediate", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.is_trivial_when_intermediate", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.column_remapping", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.column_remapping", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.reverse_mapping", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.reverse_mapping", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.mapped_columns", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.mapped_columns", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a", "b", "by", "jointype"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.by", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.by", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.jointype", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.jointype", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.id_column", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.id_column", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "record_map", "temp_namer"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.control_out_table", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.control_out_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this node is exececuted\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types", "modulename": "data_algebra.data_ops_types", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_types.PipeStep", "modulename": "data_algebra.data_ops_types", "qualname": "PipeStep", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_types.PipeStep.__init__", "modulename": "data_algebra.data_ops_types", "qualname": "PipeStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.PipeStep.apply_to", "modulename": "data_algebra.data_ops_types", "qualname": "PipeStep.apply_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform", "type": "class", "doc": "<p>Abstract class representing ability to apply data_algebra operations.</p>\n"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.__init__", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node_name", "column_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.node_name", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.node_name", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.column_map", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.column_map", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.c", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.c", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.v", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.v", "type": "function", "doc": "<p>Wrap a value</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.transform", "type": "function", "doc": "<p>apply self to data frame X, may or may not commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:param narrow logical, if True don't copy unexpected columns\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.act_on", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.act_on", "type": "function", "doc": "<p>apply self to data frame X, must commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.apply_to", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.add", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.add", "type": "function", "doc": "<p>other.apply_to(self)</p>\n\n<p>:param other:\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.columns_produced", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.columns_produced", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.to_near_sql_implementation", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.extend_parsed", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.extend_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.extend", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.extend", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.project_parsed", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.project_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.project", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.natural_join", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.natural_join", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "by", "jointype"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.concat_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.concat_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_rows_parsed", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_rows_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.drop_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.drop_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.rename_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.rename_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.order_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.order_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.convert_records", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.convert_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_map", "temp_namer"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.map_records", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.map_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "blocks_in", "blocks_out", "strict", "temp_namer"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.fit", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.fit_transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_feature_names", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_params", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.set_params", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.set_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.inverse_transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.inverse_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_utils", "modulename": "data_algebra.data_ops_utils", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_utils.try_to_merge_ops", "modulename": "data_algebra.data_ops_utils", "qualname": "try_to_merge_ops", "type": "function", "doc": "<p></p>\n", "parameters": ["ops1", "ops2"], "funcdef": "def"}, {"fullname": "data_algebra.db_model", "modulename": "data_algebra.db_model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.pretty_format_sql", "modulename": "data_algebra.db_model", "qualname": "pretty_format_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["sql", "encoding", "sqlparse_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel", "modulename": "data_algebra.db_model", "qualname": "DBModel", "type": "class", "doc": "<p>A model of how SQL should be generated for a given database.</p>\n"}, {"fullname": "data_algebra.db_model.DBModel.__init__", "modulename": "data_algebra.db_model", "qualname": "DBModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "identifier_quote", "string_quote", "sql_formatters", "op_replacements", "local_data_model", "on_start", "on_end", "on_joiner", "drop_text", "string_type", "join_name_map", "supports_with"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.identifier_quote", "modulename": "data_algebra.db_model", "qualname": "DBModel.identifier_quote", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.string_quote", "modulename": "data_algebra.db_model", "qualname": "DBModel.string_quote", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.on_start", "modulename": "data_algebra.db_model", "qualname": "DBModel.on_start", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.on_end", "modulename": "data_algebra.db_model", "qualname": "DBModel.on_end", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.on_joiner", "modulename": "data_algebra.db_model", "qualname": "DBModel.on_joiner", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.drop_text", "modulename": "data_algebra.db_model", "qualname": "DBModel.drop_text", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.string_type", "modulename": "data_algebra.db_model", "qualname": "DBModel.string_type", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.join_name_map", "modulename": "data_algebra.db_model", "qualname": "DBModel.join_name_map", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.supports_with", "modulename": "data_algebra.db_model", "qualname": "DBModel.supports_with", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBModel.db_handle", "modulename": "data_algebra.db_model", "qualname": "DBModel.db_handle", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.prepare_connection", "modulename": "data_algebra.db_model", "qualname": "DBModel.prepare_connection", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.execute", "modulename": "data_algebra.db_model", "qualname": "DBModel.execute", "type": "function", "doc": "<p>:param conn: database connectionex\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read_query", "modulename": "data_algebra.db_model", "qualname": "DBModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_exists", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_exists", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.drop_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.drop_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table_name", "check"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.insert_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.read_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table_name", "qualifiers", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read", "modulename": "data_algebra.db_model", "qualname": "DBModel.read", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_identifier", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_identifier", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "identifier"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_table_name", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_table_name", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_description"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_string", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_string", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "string"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_literal", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_literal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "val"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.value_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.value_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.expr_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.expr_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expression", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_def_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_def_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_def", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.extend_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.extend_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "extend_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.project_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.project_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "project_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.select_rows_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.select_rows_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "select_rows_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.select_columns_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.select_columns_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "select_columns_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.drop_columns_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.drop_columns_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "drop_columns_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.order_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.order_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.rename_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.rename_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "rename_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.natural_join_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.natural_join_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "join_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.concat_rows_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.concat_rows_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "concat_node", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "pretty", "annotate", "encoding", "sqlparse_options", "temp_tables", "use_with"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.row_recs_to_blocks_query", "modulename": "data_algebra.db_model", "qualname": "DBModel.row_recs_to_blocks_query", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source_sql", "record_spec", "control_view", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.blocks_to_row_recs_query", "modulename": "data_algebra.db_model", "qualname": "DBModel.blocks_to_row_recs_query", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source_sql", "record_spec", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.enc_term_", "modulename": "data_algebra.db_model", "qualname": "DBModel.enc_term_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "k", "terms"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.convert_nearsql_container_subsql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.convert_nearsql_container_subsql_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "nearsql_container", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlcte_to_sql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlcte_to_sql_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqltable_to_sql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqltable_to_sql_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlunary_to_sql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlunary_to_sql_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlbinary_to_sql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlbinary_to_sql_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "annotate", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlq_to_sql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlq_to_sql_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle", "modulename": "data_algebra.db_model", "qualname": "DBHandle", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "data_algebra.db_model.DBHandle.__init__", "modulename": "data_algebra.db_model", "qualname": "DBHandle.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.read_query", "modulename": "data_algebra.db_model", "qualname": "DBHandle.read_query", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.describe_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.describe_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name", "qualifiers", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.to_pandas", "modulename": "data_algebra.db_model", "qualname": "DBHandle.to_pandas", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "handle", "data_map"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.execute", "modulename": "data_algebra.db_model", "qualname": "DBHandle.execute", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.drop_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.drop_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.insert_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.insert_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "d", "table_name", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.to_sql", "modulename": "data_algebra.db_model", "qualname": "DBHandle.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "pretty", "annotate", "encoding", "sqlparse_options", "temp_tables", "use_with"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.query_to_csv", "modulename": "data_algebra.db_model", "qualname": "DBHandle.query_to_csv", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q", "res_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.managed_eval", "modulename": "data_algebra.db_model", "qualname": "DBHandle.managed_eval", "type": "function", "doc": "<p>apply ops to data frames in data_map</p>\n\n<p>:param ops OperatorPlatform, operation to apply OperatorPlatform\n:param data_map map from data frame names to data frame representations, altered by eval.\n:param result_name Name for result.\n:param narrow logical, if True don't copy unexpected columns\n:return: result name</p>\n", "parameters": ["self", "ops", "data_map", "result_name", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.close", "modulename": "data_algebra.db_model", "qualname": "DBHandle.close", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.diagram", "modulename": "data_algebra.diagram", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.diagram.to_digraph", "modulename": "data_algebra.diagram", "qualname": "to_digraph", "type": "function", "doc": "<p></p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.eval_model", "modulename": "data_algebra.eval_model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.eval_model.EvalModel", "modulename": "data_algebra.eval_model", "qualname": "EvalModel", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "data_algebra.eval_model.EvalModel.__init__", "modulename": "data_algebra.eval_model", "qualname": "EvalModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.eval_model.EvalModel.mk_tmp_name", "modulename": "data_algebra.eval_model", "qualname": "EvalModel.mk_tmp_name", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map"], "funcdef": "def"}, {"fullname": "data_algebra.eval_model.EvalModel.managed_eval", "modulename": "data_algebra.eval_model", "qualname": "EvalModel.managed_eval", "type": "function", "doc": "<p>apply ops to data frames in data_map</p>\n\n<p>:param ops OperatorPlatform, operation to apply OperatorPlatform\n:param data_map map from data frame names to data frame representations, altered by eval.\n:param result_name Name for result.\n:param narrow logical, if True don't copy unexpected columns\n:return: result name</p>\n", "parameters": ["self", "ops", "data_map", "result_name", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.expr_parse", "modulename": "data_algebra.expr_parse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.expr_parse.parse_assignments_in_context", "modulename": "data_algebra.expr_parse", "qualname": "parse_assignments_in_context", "type": "function", "doc": "<p>Convert all entries of ops map to Term-expressions</p>\n\n<p>:param ops: dictionary from strings to expressions (either Terms or strings)\n:param view: a data_algebra.data_ops.ViewRepresentation\n:return:</p>\n", "parameters": ["ops", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep", "modulename": "data_algebra.expr_rep", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.expr_rep.PreTerm", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm", "type": "class", "doc": "<p>abstract base class, without combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.PreTerm.__init__", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.source_string", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.source_string", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.expr_rep.PreTerm.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.get_views", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.to_python", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.to_python", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.to_source", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.to_source", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "want_inline_parens", "dialect"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term", "modulename": "data_algebra.expr_rep", "qualname": "Term", "type": "class", "doc": "<p>Abstract intermediate class with combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.Term.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Term.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sign", "modulename": "data_algebra.expr_rep", "qualname": "Term.sign", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sin", "modulename": "data_algebra.expr_rep", "qualname": "Term.sin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cos", "modulename": "data_algebra.expr_rep", "qualname": "Term.cos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arcsin", "modulename": "data_algebra.expr_rep", "qualname": "Term.arcsin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arccos", "modulename": "data_algebra.expr_rep", "qualname": "Term.arccos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctan", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctan", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctan2", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctan2", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sinh", "modulename": "data_algebra.expr_rep", "qualname": "Term.sinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cosh", "modulename": "data_algebra.expr_rep", "qualname": "Term.cosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.tanh", "modulename": "data_algebra.expr_rep", "qualname": "Term.tanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arcsinh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arcsinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arccosh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arccosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctanh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.floor", "modulename": "data_algebra.expr_rep", "qualname": "Term.floor", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ceil", "modulename": "data_algebra.expr_rep", "qualname": "Term.ceil", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sum", "modulename": "data_algebra.expr_rep", "qualname": "Term.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumprod", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumprod", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumsum", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumsum", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.exp", "modulename": "data_algebra.expr_rep", "qualname": "Term.exp", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.expm1", "modulename": "data_algebra.expr_rep", "qualname": "Term.expm1", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log", "modulename": "data_algebra.expr_rep", "qualname": "Term.log", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log10", "modulename": "data_algebra.expr_rep", "qualname": "Term.log10", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log1p", "modulename": "data_algebra.expr_rep", "qualname": "Term.log1p", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.mod", "modulename": "data_algebra.expr_rep", "qualname": "Term.mod", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.remainder", "modulename": "data_algebra.expr_rep", "qualname": "Term.remainder", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sqrt", "modulename": "data_algebra.expr_rep", "qualname": "Term.sqrt", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.abs", "modulename": "data_algebra.expr_rep", "qualname": "Term.abs", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.maximum", "modulename": "data_algebra.expr_rep", "qualname": "Term.maximum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.minimum", "modulename": "data_algebra.expr_rep", "qualname": "Term.minimum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.fmax", "modulename": "data_algebra.expr_rep", "qualname": "Term.fmax", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.fmin", "modulename": "data_algebra.expr_rep", "qualname": "Term.fmin", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.round", "modulename": "data_algebra.expr_rep", "qualname": "Term.round", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.around", "modulename": "data_algebra.expr_rep", "qualname": "Term.around", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.all", "modulename": "data_algebra.expr_rep", "qualname": "Term.all", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.any", "modulename": "data_algebra.expr_rep", "qualname": "Term.any", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.bfill", "modulename": "data_algebra.expr_rep", "qualname": "Term.bfill", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.count", "modulename": "data_algebra.expr_rep", "qualname": "Term.count", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumcount", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumcount", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cummax", "modulename": "data_algebra.expr_rep", "qualname": "Term.cummax", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cummin", "modulename": "data_algebra.expr_rep", "qualname": "Term.cummin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ffill", "modulename": "data_algebra.expr_rep", "qualname": "Term.ffill", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.first", "modulename": "data_algebra.expr_rep", "qualname": "Term.first", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.head", "modulename": "data_algebra.expr_rep", "qualname": "Term.head", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_monotonic_decreasing", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_monotonic_decreasing", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_monotonic_increasing", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_monotonic_increasing", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.last", "modulename": "data_algebra.expr_rep", "qualname": "Term.last", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.max", "modulename": "data_algebra.expr_rep", "qualname": "Term.max", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.mean", "modulename": "data_algebra.expr_rep", "qualname": "Term.mean", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.median", "modulename": "data_algebra.expr_rep", "qualname": "Term.median", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.min", "modulename": "data_algebra.expr_rep", "qualname": "Term.min", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ngroup", "modulename": "data_algebra.expr_rep", "qualname": "Term.ngroup", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nlargest", "modulename": "data_algebra.expr_rep", "qualname": "Term.nlargest", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nsmallest", "modulename": "data_algebra.expr_rep", "qualname": "Term.nsmallest", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nth", "modulename": "data_algebra.expr_rep", "qualname": "Term.nth", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nunique", "modulename": "data_algebra.expr_rep", "qualname": "Term.nunique", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.rank", "modulename": "data_algebra.expr_rep", "qualname": "Term.rank", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.size", "modulename": "data_algebra.expr_rep", "qualname": "Term.size", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.std", "modulename": "data_algebra.expr_rep", "qualname": "Term.std", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.unique", "modulename": "data_algebra.expr_rep", "qualname": "Term.unique", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.value_counts", "modulename": "data_algebra.expr_rep", "qualname": "Term.value_counts", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.var", "modulename": "data_algebra.expr_rep", "qualname": "Term.var", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.shift", "modulename": "data_algebra.expr_rep", "qualname": "Term.shift", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_null", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_null", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_bad", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_bad", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.if_else", "modulename": "data_algebra.expr_rep", "qualname": "Term.if_else", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x", "y"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_in", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_in", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.concat", "modulename": "data_algebra.expr_rep", "qualname": "Term.concat", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.coalesce", "modulename": "data_algebra.expr_rep", "qualname": "Term.coalesce", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.co_equalizer", "modulename": "data_algebra.expr_rep", "qualname": "Term.co_equalizer", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.as_int64", "modulename": "data_algebra.expr_rep", "qualname": "Term.as_int64", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.as_str", "modulename": "data_algebra.expr_rep", "qualname": "Term.as_str", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.trimstr", "modulename": "data_algebra.expr_rep", "qualname": "Term.trimstr", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "start", "stop"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.coalesce_0", "modulename": "data_algebra.expr_rep", "qualname": "Term.coalesce_0", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.datetime_to_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.datetime_to_date", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.parse_datetime", "modulename": "data_algebra.expr_rep", "qualname": "Term.parse_datetime", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.parse_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.parse_date", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.format_datetime", "modulename": "data_algebra.expr_rep", "qualname": "Term.format_datetime", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.format_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.format_date", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofweek", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofweek", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofyear", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofyear", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofmonth", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofmonth", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.weekofyear", "modulename": "data_algebra.expr_rep", "qualname": "Term.weekofyear", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.month", "modulename": "data_algebra.expr_rep", "qualname": "Term.month", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.quarter", "modulename": "data_algebra.expr_rep", "qualname": "Term.quarter", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.year", "modulename": "data_algebra.expr_rep", "qualname": "Term.year", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.timestamp_diff", "modulename": "data_algebra.expr_rep", "qualname": "Term.timestamp_diff", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.date_diff", "modulename": "data_algebra.expr_rep", "qualname": "Term.date_diff", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.base_Sunday", "modulename": "data_algebra.expr_rep", "qualname": "Term.base_Sunday", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value", "modulename": "data_algebra.expr_rep", "qualname": "Value", "type": "class", "doc": "<p>Abstract intermediate class with combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.Value.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Value.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "Value.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.get_views", "modulename": "data_algebra.expr_rep", "qualname": "Value.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "Value.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "Value.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.to_python", "modulename": "data_algebra.expr_rep", "qualname": "Value.to_python", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.UnQuotedStr", "modulename": "data_algebra.expr_rep", "qualname": "UnQuotedStr", "type": "class", "doc": "<p>str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str</p>\n\n<p>Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.</p>\n"}, {"fullname": "data_algebra.expr_rep.UnQuotedStr.__init__", "modulename": "data_algebra.expr_rep", "qualname": "UnQuotedStr.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.UnQuotedStr.str", "modulename": "data_algebra.expr_rep", "qualname": "UnQuotedStr.str", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm", "type": "class", "doc": "<p>abstract base class, without combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.ListTerm.__init__", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.get_views", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.to_python", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.to_python", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference", "type": "class", "doc": "<p>class to represent referring to a column</p>\n"}, {"fullname": "data_algebra.expr_rep.ColumnReference.__init__", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view", "column_name"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.view", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.view", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.expr_rep.ColumnReference.column_name", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.column_name", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.expr_rep.ColumnReference.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.get_views", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.to_python", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.to_python", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression", "modulename": "data_algebra.expr_rep", "qualname": "Expression", "type": "class", "doc": "<p>Abstract intermediate class with combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.Expression.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Expression.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "args", "params", "inline", "method"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "Expression.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.get_views", "modulename": "data_algebra.expr_rep", "qualname": "Expression.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "Expression.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "Expression.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "Expression.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.to_python", "modulename": "data_algebra.expr_rep", "qualname": "Expression.to_python", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.connected_components", "modulename": "data_algebra.expr_rep", "qualname": "connected_components", "type": "function", "doc": "<p></p>\n", "parameters": ["f", "g"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.populate_specials", "modulename": "data_algebra.expr_rep", "qualname": "populate_specials", "type": "function", "doc": "<p>populate a dictionary with special values\ncolumn_defs is a dictionary,\n  usually formed from a ViewRepresentation.column_map\ndestination is a dictionary,\n  usually formed from a ViewRepresentation.column_map.copy()</p>\n", "parameters": ["column_defs", "destination", "user_values"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.standardize_join_type", "modulename": "data_algebra.expr_rep", "qualname": "standardize_join_type", "type": "function", "doc": "<p></p>\n", "parameters": ["join_str"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.get_columns_used", "modulename": "data_algebra.expr_rep", "qualname": "get_columns_used", "type": "function", "doc": "<p></p>\n", "parameters": ["parsed_exprs"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.implies_windowed", "modulename": "data_algebra.expr_rep", "qualname": "implies_windowed", "type": "function", "doc": "<p></p>\n", "parameters": ["parsed_exprs"], "funcdef": "def"}, {"fullname": "data_algebra.flow_text", "modulename": "data_algebra.flow_text", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.flow_text.flow_text", "modulename": "data_algebra.flow_text", "qualname": "flow_text", "type": "function", "doc": "<p>:param tokens: list or tuple of strings\n:param align_right: integer, right alignment margin\n:param sep_width: integer, size of inline separator\n:return: list of lists of strings flowing the text to the margin</p>\n", "parameters": ["tokens", "align_right", "sep_width"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql", "modulename": "data_algebra.near_sql", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.near_sql.NearSQL", "modulename": "data_algebra.near_sql", "qualname": "NearSQL", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQL.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "temp_tables", "is_table", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_bound_near_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_bound_near_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer", "type": "class", "doc": "<p>NearSQL with bound in columns, force_sql, and constants decisions</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.to_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.convert_subsql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.convert_subsql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.to_with_form_stub", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.to_with_form_stub", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression.to_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLTable", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLTable.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "quoted_table_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLTable.to_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "sub_sql", "suffix", "temp_tables", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.to_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "sub_sql1", "joiner", "sub_sql2", "suffix", "temp_tables", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.to_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLq", "modulename": "data_algebra.near_sql", "qualname": "NearSQLq", "type": "class", "doc": "<p>Adapter to wrap a pre-existing query as a NearSQL</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLq.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLq.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "quoted_query_name", "query", "terms", "prev_quoted_query_name", "temp_tables", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLq.to_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLq.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "annotate"], "funcdef": "def"}, {"fullname": "data_algebra.op_container", "modulename": "data_algebra.op_container", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.op_container.OpC", "modulename": "data_algebra.op_container", "qualname": "OpC", "type": "class", "doc": "<p>Container that redirects to another to allow method chaining.</p>\n"}, {"fullname": "data_algebra.op_container.OpC.__init__", "modulename": "data_algebra.op_container", "qualname": "OpC.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.set", "modulename": "data_algebra.op_container", "qualname": "OpC.set", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.describe_table", "modulename": "data_algebra.op_container", "qualname": "OpC.describe_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "d", "table_name", "qualifiers", "sql_meta", "column_types", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.ops", "modulename": "data_algebra.op_container", "qualname": "OpC.ops", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.transform", "modulename": "data_algebra.op_container", "qualname": "OpC.transform", "type": "function", "doc": "<p>apply self to data frame X, may or may not commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:param narrow logical, if True don't copy unexpected columns\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.act_on", "modulename": "data_algebra.op_container", "qualname": "OpC.act_on", "type": "function", "doc": "<p>apply self to data frame X, must commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.apply_to", "modulename": "data_algebra.op_container", "qualname": "OpC.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.add", "modulename": "data_algebra.op_container", "qualname": "OpC.add", "type": "function", "doc": "<p>other.apply_to(self)</p>\n\n<p>:param other:\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.columns_produced", "modulename": "data_algebra.op_container", "qualname": "OpC.columns_produced", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.to_near_sql_implementation", "modulename": "data_algebra.op_container", "qualname": "OpC.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.extend_parsed", "modulename": "data_algebra.op_container", "qualname": "OpC.extend_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.extend", "modulename": "data_algebra.op_container", "qualname": "OpC.extend", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.project_parsed", "modulename": "data_algebra.op_container", "qualname": "OpC.project_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.project", "modulename": "data_algebra.op_container", "qualname": "OpC.project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.natural_join", "modulename": "data_algebra.op_container", "qualname": "OpC.natural_join", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "by", "jointype"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.concat_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.concat_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_rows_parsed", "modulename": "data_algebra.op_container", "qualname": "OpC.select_rows_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.select_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.drop_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.drop_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.select_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.rename_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.rename_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.order_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.order_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.convert_records", "modulename": "data_algebra.op_container", "qualname": "OpC.convert_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_map", "temp_namer"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.map_records", "modulename": "data_algebra.op_container", "qualname": "OpC.map_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "blocks_in", "blocks_out", "strict", "temp_namer"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.fit", "modulename": "data_algebra.op_container", "qualname": "OpC.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.fit_transform", "modulename": "data_algebra.op_container", "qualname": "OpC.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.get_feature_names", "modulename": "data_algebra.op_container", "qualname": "OpC.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base", "modulename": "data_algebra.pandas_base", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.pandas_base.PandasModelBase", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.__init__", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pd", "presentation_model_name"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.data_frame", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.data_frame", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "arg"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.is_appropriate_data_instance", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.is_appropriate_data_instance", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "df"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.can_convert_col_to_numeric", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.can_convert_col_to_numeric", "type": "function", "doc": "<p>check if non-empty vector can convert to numeric</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.to_numeric", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.to_numeric", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x", "errors"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.isnull", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.isnull", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.bad_column_positions", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.bad_column_positions", "type": "function", "doc": "<p>for numeric vector x, return logical vector of positions that are null, NaN, infinite</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.table_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.table_step", "type": "function", "doc": "<p>Represents a data input.</p>\n\n<p>:param op:\n:param data_map:\n:param narrow:\n:return:</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.extend_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.extend_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.columns_to_frame", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.columns_to_frame", "type": "function", "doc": "<p>:param cols: dictionary mapping column names to columns\n:return:</p>\n", "parameters": ["self", "cols"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.project_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.project_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.select_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.select_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.select_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.select_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.drop_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.drop_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.order_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.order_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.rename_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.rename_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.standardize_join_code", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.standardize_join_code", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "jointype"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.natural_join_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.natural_join_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.concat_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.concat_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.convert_records_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.convert_records_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_model", "modulename": "data_algebra.pandas_model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.pandas_model.PandasModel", "modulename": "data_algebra.pandas_model", "qualname": "PandasModel", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "data_algebra.pandas_model.PandasModel.__init__", "modulename": "data_algebra.pandas_model", "qualname": "PandasModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pd", "presentation_model_name"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_model.PandasModel.managed_eval", "modulename": "data_algebra.pandas_model", "qualname": "PandasModel.managed_eval", "type": "function", "doc": "<p>apply ops to data frames in data_map</p>\n\n<p>:param ops OperatorPlatform, operation to apply OperatorPlatform\n:param data_map map from data frame names to data frame representations, altered by eval.\n:param result_name Name for result.\n:param narrow logical, if True don't copy unexpected columns\n:return: result name</p>\n", "parameters": ["self", "ops", "data_map", "result_name", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.parse_by_lark", "modulename": "data_algebra.parse_by_lark", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.parse_by_lark.parse_by_lark", "modulename": "data_algebra.parse_by_lark", "qualname": "parse_by_lark", "type": "function", "doc": "<p>Parse an expression in terms of data views and values.</p>\n\n<p>:param source_str: string to parse\n:param data_def: dictionary of data_algebra.expr_rep.ColumnReference\n:return:</p>\n", "parameters": ["source_str", "data_def"], "funcdef": "def"}, {"fullname": "data_algebra.python3_lark", "modulename": "data_algebra.python3_lark", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.test_util", "modulename": "data_algebra.test_util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.test_util.formats_to_self", "modulename": "data_algebra.test_util", "qualname": "formats_to_self", "type": "function", "doc": "<p>Check a operator dag formats and parses back to itself.\nCan raise exceptions. Also checks pickling.</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:return: logical, True if formats and evals back to self</p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.equivalent_frames", "modulename": "data_algebra.test_util", "qualname": "equivalent_frames", "type": "function", "doc": "<p>return False if the frames are equivalent (up to column re-ordering and possible row-reordering).\nIgnores indexing.</p>\n", "parameters": ["a", "b", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.check_transform_on_handles", "modulename": "data_algebra.test_util", "qualname": "check_transform_on_handles", "type": "function", "doc": "<p>Test an operator dag produces the expected result, and parses correctly.\nAsserts if there are issues</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:param data: pd.DataFrame or map of strings to pd.DataFrame\n:param expect: pd.DataFrame\n:param db_handles:  list of database handles to use in testing\n:param float_tol: passed to equivalent_frames()\n:param check_column_order: passed to equivalent_frames()\n:param cols_case_sensitive: passed to equivalent_frames()\n:param check_row_order: passed to equivalent_frames()\n:param check_parse: if True check expression parses/formats to self\n:param local_data_model: optional alternate evaluation model\n:param allow_pretty: if True try pretty printing SQL\n:return: None, assert if there is an issue</p>\n", "parameters": ["ops", "data", "expect", "db_handles", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "check_parse", "local_data_model", "allow_pretty"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.check_transform", "modulename": "data_algebra.test_util", "qualname": "check_transform", "type": "function", "doc": "<p>Test an operator dag produces the expected result, and parses correctly.\nAssert if there are issues.</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:param data: pd.DataFrame or map of strings to pd.DataFrame\n:param expect: pd.DataFrame\n:param float_tol: passed to equivalent_frames()\n:param check_column_order: passed to equivalent_frames()\n:param cols_case_sensitive: passed to equivalent_frames()\n:param check_row_order: passed to equivalent_frames()\n:param check_parse: if True check expression parses/formats to self\n:param allow_pretty: if True try pretty printing SQL\n:param models_to_skip: None or set of model names to skip testing\n:return: nothing</p>\n", "parameters": ["ops", "data", "expect", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "check_parse", "allow_pretty", "models_to_skip"], "funcdef": "def"}, {"fullname": "data_algebra.util", "modulename": "data_algebra.util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.util.pandas_to_example_str", "modulename": "data_algebra.util", "qualname": "pandas_to_example_str", "type": "function", "doc": "<p></p>\n", "parameters": ["obj", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.util.table_is_keyed_by_columns", "modulename": "data_algebra.util", "qualname": "table_is_keyed_by_columns", "type": "function", "doc": "<p>:param table: pandas DataFrame\n:param column_names: list of column names\n:return: True if rows are uniquely keyed by values in named columns</p>\n", "parameters": ["table", "column_names"], "funcdef": "def"}]
[{"fullname": "data_algebra", "modulename": "data_algebra", "qualname": "", "type": "module", "doc": "<p><code>data_algebra</code><a href=\"https://github.com/WinVector/data_algebra\">https://github.com/WinVector/data_algebra</a> is a piped data wrangling system\nbased on Codd's relational algebra and experience working with dplyr at scale.  The primary \npurpose of the package is to support an easy to compose and maintain grammar of data processing\nsteps that in turn can be used to generate database specific SQL.  The package also implements\nthe same transforms for Pandas DataFrames. </p>\n\n<p>This package is still under initial development, so some parts are not yet implemented or tested, and APIs\nare subject to change.</p>\n\n<p>Mature, production ready <code>R</code><a href=\"https://www.r-project.org\">https://www.r-project.org</a> versions of the system are available as \nthe <code>rquery</code><a href=\"https://github.com/WinVector/rquery\">https://github.com/WinVector/rquery</a> and <code>rqdatatable</code><a href=\"https://github.com/WinVector/rqdatatable\">https://github.com/WinVector/rqdatatable</a> packages.</p>\n"}, {"fullname": "data_algebra.BigQuery", "modulename": "data_algebra.BigQuery", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.BigQuery.BigQueryModel", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel", "type": "class", "doc": "<p>A model of how SQL should be generated for BigQuery\nconnection should be google.cloud.bigquery.client.Client</p>\n"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.__init__", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_prefix"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.quote_table_name", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.quote_table_name", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_description"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.execute", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.execute", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.read_query", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.insert_table", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQueryModel.db_handle", "modulename": "data_algebra.BigQuery", "qualname": "BigQueryModel.db_handle", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.__init__", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.describe_bq_table", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.describe_bq_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_catalog", "table_schema", "table_name", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.BigQuery_DBHandle.query_to_csv", "modulename": "data_algebra.BigQuery", "qualname": "BigQuery_DBHandle.query_to_csv", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q", "res_name"], "funcdef": "def"}, {"fullname": "data_algebra.BigQuery.example_handle", "modulename": "data_algebra.BigQuery", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.\nNote: binds in a data_catalog and data schema prefix. So this handle is specific\nto one database.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.MySQL", "modulename": "data_algebra.MySQL", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.MySQL.MySQLModel", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for MySQL.\nAssuming we are using a sqlalchemy engine as our connection.</p>\n"}, {"fullname": "data_algebra.MySQL.MySQLModel.__init__", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "supports_with"], "funcdef": "def"}, {"fullname": "data_algebra.MySQL.MySQLModel.quote_identifier", "modulename": "data_algebra.MySQL", "qualname": "MySQLModel.quote_identifier", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "identifier"], "funcdef": "def"}, {"fullname": "data_algebra.MySQL.example_handle", "modulename": "data_algebra.MySQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet", "modulename": "data_algebra.OrderedSet", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet", "type": "class", "doc": "<p>Dictionary that remembers insertion order</p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.__init__", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.update", "type": "function", "doc": "<p>D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.add", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.add", "type": "function", "doc": "<p>Add an element.</p>\n", "parameters": ["self", "elem"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.discard", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.discard", "type": "function", "doc": "<p>Remove an element.  Do not raise an exception if absent.</p>\n", "parameters": ["self", "elem"], "funcdef": "def"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.difference", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.difference", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.difference_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.difference_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.intersection", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.intersection", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.intersection_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.intersection_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.issubset", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.issubset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.issuperset", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.issuperset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.symmetric_difference", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.symmetric_difference", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.symmetric_difference_update", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.symmetric_difference_update", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "data_algebra.OrderedSet.OrderedSet.union", "modulename": "data_algebra.OrderedSet", "qualname": "OrderedSet.union", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args"], "funcdef": "def"}, {"fullname": "data_algebra.PostgreSQL", "modulename": "data_algebra.PostgreSQL", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.PostgreSQL.PostgreSQLModel", "modulename": "data_algebra.PostgreSQL", "qualname": "PostgreSQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for PostgreSQL.\nAssuming we are using a sqlalchemy engine as our connection</p>\n"}, {"fullname": "data_algebra.PostgreSQL.PostgreSQLModel.__init__", "modulename": "data_algebra.PostgreSQL", "qualname": "PostgreSQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.PostgreSQL.example_handle", "modulename": "data_algebra.PostgreSQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.SQLite", "modulename": "data_algebra.SQLite", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SQLite.MedianAgg", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SQLite.MedianAgg.__init__", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.MedianAgg.step", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.MedianAgg.finalize", "modulename": "data_algebra.SQLite", "qualname": "MedianAgg.finalize", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel", "type": "class", "doc": "<p>A model of how SQL should be generated for SQLite</p>\n"}, {"fullname": "data_algebra.SQLite.SQLiteModel.__init__", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.prepare_connection", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.prepare_connection", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.insert_table", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.insert_table", "type": "function", "doc": "<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.SQLiteModel.natural_join_to_sql", "modulename": "data_algebra.SQLite", "qualname": "SQLiteModel.natural_join_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "join_node", "using", "temp_id_source", "sql_format_options", "left_is_first"], "funcdef": "def"}, {"fullname": "data_algebra.SQLite.example_handle", "modulename": "data_algebra.SQLite", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL", "modulename": "data_algebra.SparkSQL", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkConnection", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkConnection.__init__", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "spark_context", "spark_session"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkConnection.close", "modulename": "data_algebra.SparkSQL", "qualname": "SparkConnection.close", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel", "type": "class", "doc": "<p>A model of how SQL should be generated for SparkSQL.</p>\n\n<p>Known issue: doesn't coalesce NaN</p>\n"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.__init__", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.execute", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.execute", "type": "function", "doc": "<p>:param conn: database connectionex\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.read_query", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.SparkSQLModel.insert_table", "modulename": "data_algebra.SparkSQL", "qualname": "SparkSQLModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.SparkSQL.example_handle", "modulename": "data_algebra.SparkSQL", "qualname": "example_handle", "type": "function", "doc": "<p>Return an example db handle for testing. Returns None if helper packages not present.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.arrow", "modulename": "data_algebra.arrow", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.arrow.Arrow", "modulename": "data_algebra.arrow", "qualname": "Arrow", "type": "class", "doc": "<p>Arrow from category theory: see Steve Awody, \"Category Theory, 2nd Edition\", Oxford Univ. Press, 2010 pg. 4.</p>\n"}, {"fullname": "data_algebra.arrow.Arrow.__init__", "modulename": "data_algebra.arrow", "qualname": "Arrow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.dom", "modulename": "data_algebra.arrow", "qualname": "Arrow.dom", "type": "function", "doc": "<p>return domain, object at base of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.cod", "modulename": "data_algebra.arrow", "qualname": "Arrow.cod", "type": "function", "doc": "<p>return co-domain, object at head of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.apply_to", "modulename": "data_algebra.arrow", "qualname": "Arrow.apply_to", "type": "function", "doc": "<p>apply_to b, compose arrows (right to left)</p>\n", "parameters": ["self", "b"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.act_on", "modulename": "data_algebra.arrow", "qualname": "Arrow.act_on", "type": "function", "doc": "<p>act on X, must associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.transform", "type": "function", "doc": "<p>transform X, may or may not associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.fit", "modulename": "data_algebra.arrow", "qualname": "Arrow.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.fit_transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.get_feature_names", "modulename": "data_algebra.arrow", "qualname": "Arrow.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.get_params", "modulename": "data_algebra.arrow", "qualname": "Arrow.get_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.set_params", "modulename": "data_algebra.arrow", "qualname": "Arrow.set_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.Arrow.inverse_transform", "modulename": "data_algebra.arrow", "qualname": "Arrow.inverse_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow", "type": "class", "doc": "<p>Represent a dag of operators as a categorical arrow.</p>\n"}, {"fullname": "data_algebra.arrow.DataOpArrow.__init__", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pipeline", "free_table_key", "strict", "forbidden_to_produce"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.get_feature_names", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.apply_to", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.apply_to", "type": "function", "doc": "<p>replace self input table with b</p>\n", "parameters": ["self", "b"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.act_on", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.act_on", "type": "function", "doc": "<p>act on X, must associate with composition</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.learn_types", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.learn_types", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_in", "data_out"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.fit", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.fit", "type": "function", "doc": "<p>Learn input and output types from example, and return self</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.fit_transform", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.fit_transform", "type": "function", "doc": "<p>Learn input and output types from example, and return transform.</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.dom", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.dom", "type": "function", "doc": "<p>return domain, object at base of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.dom_as_table", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.dom_as_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.cod", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.cod", "type": "function", "doc": "<p>return co-domain, object at head of arrow</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.cod_as_table", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.cod_as_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.required_columns", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.required_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.forbidden_columns", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.forbidden_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.DataOpArrow.format_end_description", "modulename": "data_algebra.arrow", "qualname": "DataOpArrow.format_end_description", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "required_cols", "col_types", "forbidden_cols", "align_right", "sep_width"], "funcdef": "def"}, {"fullname": "data_algebra.arrow.fmt_as_arrow", "modulename": "data_algebra.arrow", "qualname": "fmt_as_arrow", "type": "function", "doc": "<p></p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.cdata", "modulename": "data_algebra.cdata", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.cdata.RecordSpecification", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification", "type": "class", "doc": "<p>Class to represent a multi-row data record.</p>\n"}, {"fullname": "data_algebra.cdata.RecordSpecification.__init__", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.__init__", "type": "function", "doc": "<p>:param control_table: data.frame describing record layout\n:param record_keys: array of record key column names\n       defaults to no columns.\n:param control_table_keys: array of control_table key column names,\n       defaults to first column for non-trivial blocks and no columns for rows.\n:param strict: logical, if True more checks on transform\n:param local_data_model: data.frame data model</p>\n", "parameters": ["self", "control_table", "record_keys", "control_table_keys", "strict", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.row_version", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.row_version", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "include_record_keys"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.fmt", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.fmt", "type": "function", "doc": "<p>Prepare for printing</p>\n\n<p>:return: multi line string representation.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.map_to_rows", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.map_to_rows", "type": "function", "doc": "<p>Build a RecordMap mapping this RecordSpecification to rowrecs</p>\n\n<p>:return: RecordMap</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordSpecification.map_from_rows", "modulename": "data_algebra.cdata", "qualname": "RecordSpecification.map_from_rows", "type": "function", "doc": "<p>Build a RecordMap mapping this RecordSpecification from rowrecs</p>\n\n<p>:return: RecordMap</p>\n", "parameters": ["self", "strict"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.blocks_to_rowrecs", "modulename": "data_algebra.cdata", "qualname": "blocks_to_rowrecs", "type": "function", "doc": "<p></p>\n", "parameters": ["data", "blocks_in", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.rowrecs_to_blocks", "modulename": "data_algebra.cdata", "qualname": "rowrecs_to_blocks", "type": "function", "doc": "<p></p>\n", "parameters": ["data", "blocks_out", "check_blocks_out_keying", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap", "modulename": "data_algebra.cdata", "qualname": "RecordMap", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.cdata.RecordMap.__init__", "modulename": "data_algebra.cdata", "qualname": "RecordMap.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "blocks_in", "blocks_out"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.record_keys", "modulename": "data_algebra.cdata", "qualname": "RecordMap.record_keys", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.example_input", "modulename": "data_algebra.cdata", "qualname": "RecordMap.example_input", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "check_blocks_out_keying", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.compose", "modulename": "data_algebra.cdata", "qualname": "RecordMap.compose", "type": "function", "doc": "<p>Experimental method to compose transforms\n(self.compose(other)).transform(data) == self.transform(other.transform(data))</p>\n\n<p>:param other: another data_algebra.cdata.RecordMap\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.inverse", "modulename": "data_algebra.cdata", "qualname": "RecordMap.inverse", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fmt", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fmt", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fit", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.fit_transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.get_feature_names", "modulename": "data_algebra.cdata", "qualname": "RecordMap.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.get_params", "modulename": "data_algebra.cdata", "qualname": "RecordMap.get_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.set_params", "modulename": "data_algebra.cdata", "qualname": "RecordMap.set_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.RecordMap.inverse_transform", "modulename": "data_algebra.cdata", "qualname": "RecordMap.inverse_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.pivot_blocks_to_rowrecs", "modulename": "data_algebra.cdata", "qualname": "pivot_blocks_to_rowrecs", "type": "function", "doc": "<p>Build a block records to row records map. This is very similar to a SQL pivot.</p>\n\n<p>:param attribute_key_column: column to identify record attribute keys\n:param attribute_value_column: column for record attribute values\n:param record_keys: names of key columns identifying row record blocks\n:param record_value_columns: names of columns to take row record values from\n:param local_data_model: data.frame data model\n:return: RecordMap</p>\n", "parameters": ["attribute_key_column", "attribute_value_column", "record_keys", "record_value_columns", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.cdata.pivot_rowrecs_to_blocks", "modulename": "data_algebra.cdata", "qualname": "pivot_rowrecs_to_blocks", "type": "function", "doc": "<p>Build a row records to block records map. This is very similar to a SQL unpivot.</p>\n\n<p>:param attribute_key_column: column to identify record attribute keys\n:param attribute_value_column: column for record attribute values\n:param record_keys: names of key columns identifying row record blocks\n:param record_value_columns: names of columns to take row record values from\n:param local_data_model: data.frame data model\n:return: RecordMap</p>\n", "parameters": ["attribute_key_column", "attribute_value_column", "record_keys", "record_value_columns", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.connected_components", "modulename": "data_algebra.connected_components", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.connected_components.Component", "modulename": "data_algebra.connected_components", "qualname": "Component", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.connected_components.Component.__init__", "modulename": "data_algebra.connected_components", "qualname": "Component.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "item"], "funcdef": "def"}, {"fullname": "data_algebra.connected_components.connected_components", "modulename": "data_algebra.connected_components", "qualname": "connected_components", "type": "function", "doc": "<p>Compute connected components of undirected edges (f[i], g[i]).</p>\n\n<p>For the return value we are using the\ncategory formulation that these are the co-equalizer of f and g,\nmeaning it is a finest partition such that return[f[i]] = return[g[i]]\nfor all i.  We pick the least item in each component as the representation.\nThis is just a long way of saying: as each side of an edge is in the same\ncomponent, we return the assignment by labeling the edges by components\n(instead of the vertices).</p>\n\n<p>Not as fast as union/find but fast.</p>\n\n<p>f = [1, 4, 6, 2, 1]\ng = [2, 5, 7, 3, 7]\nres = connected_components(f, g)\nprint(res)</p>\n\n<p>:param f: list or vector of hashable/comparable items of length n\n:param g: list or vector of hashable/comparable items of length n\n:return: list of assignments of length n (map both f and g to same values.</p>\n", "parameters": ["f", "g"], "funcdef": "def"}, {"fullname": "data_algebra.data_model", "modulename": "data_algebra.data_model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_model.DataModel", "modulename": "data_algebra.data_model", "qualname": "DataModel", "type": "class", "doc": "<p>Interface for realizing the data algebra as a sequence of steps over an object.</p>\n"}, {"fullname": "data_algebra.data_model.DataModel.__init__", "modulename": "data_algebra.data_model", "qualname": "DataModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "presentation_model_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.data_frame", "modulename": "data_algebra.data_model", "qualname": "DataModel.data_frame", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "arg"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.is_appropriate_data_instance", "modulename": "data_algebra.data_model", "qualname": "DataModel.is_appropriate_data_instance", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "df"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.can_convert_col_to_numeric", "modulename": "data_algebra.data_model", "qualname": "DataModel.can_convert_col_to_numeric", "type": "function", "doc": "<p>check if non-empty vector can convert to numeric</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.to_numeric", "modulename": "data_algebra.data_model", "qualname": "DataModel.to_numeric", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x", "errors"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.isnull", "modulename": "data_algebra.data_model", "qualname": "DataModel.isnull", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.bad_column_positions", "modulename": "data_algebra.data_model", "qualname": "DataModel.bad_column_positions", "type": "function", "doc": "<p>for numeric vector x, return logical vector of positions that are null, NaN, infinite</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.table_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.table_step", "type": "function", "doc": "<p>Represents a data input.</p>\n\n<p>:param op:\n:param data_map:\n:param narrow:\n:return:</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.extend_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.extend_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.project_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.project_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.select_rows_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.select_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.select_columns_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.select_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.drop_columns_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.drop_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.order_rows_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.order_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.rename_columns_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.rename_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.natural_join_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.natural_join_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.concat_rows_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.concat_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_model.DataModel.convert_records_step", "modulename": "data_algebra.data_model", "qualname": "DataModel.convert_records_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops", "modulename": "data_algebra.data_ops", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops.pretty_format_python", "modulename": "data_algebra.data_ops", "qualname": "pretty_format_python", "type": "function", "doc": "<p></p>\n", "parameters": ["python_str", "black_mode"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.__init__", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_names", "column_types", "sources", "node_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.merged_rep_id", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.merged_rep_id", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.ex", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["self", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.get_tables", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.get_tables", "type": "function", "doc": "<p>Get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_produced", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_produced", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.columns_used", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.columns_used", "type": "function", "doc": "<p>Determine which columns are used from source tables.</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_python", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_python", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "pretty", "black_mode"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.to_sql", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.check_constraints", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.check_constraints", "type": "function", "doc": "<p>Check tables supplied meet data consistency constraints.</p>\n\n<p>data_model: dictionary of column name lists.</p>\n", "parameters": ["self", "data_model", "strict"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.eval", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.eval", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames.</p>\n\n<p>:param data_map: map from table names to data frames\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow logical, if True don't copy unexpected columns\n:return: table result</p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.transform", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.transform", "type": "function", "doc": "<p>Apply data transform to a table</p>\n\n<p>:param X: tale to apply to\n:param data_model: data model for Pandas execution\n:param narrow: logical, if True narrow number of result columns to specification</p>\n", "parameters": ["self", "X", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.is_trivial_when_intermediate", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.is_trivial_when_intermediate", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.as_table_description", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.as_table_description", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name", "qualifiers", "column_types"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.extend_parsed", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.extend_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.extend", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.extend", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.project_parsed", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.project_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.project", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.natural_join", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.natural_join", "type": "function", "doc": "<p>:param b: right table\n:param by: list of keys to join by\n:param jointype: one of 'INNER', 'LEFT', 'RIGHT', 'OUTER', 'FULL', 'CROSS' (case insensitive)\n:param check_all_common_keys_in_by: logical if True don't allow shared column names that are not in by-term\n:return: ops describing join</p>\n", "parameters": ["self", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.concat_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.concat_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_rows_parsed", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_rows_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.drop_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.drop_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.select_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.select_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.rename_columns", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.rename_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.order_rows", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.order_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ViewRepresentation.convert_records", "modulename": "data_algebra.data_ops", "qualname": "ViewRepresentation.convert_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription", "modulename": "data_algebra.data_ops", "qualname": "TableDescription", "type": "class", "doc": "<p>Describe columns, and qualifiers, of a table.</p>\n\n<p>Example:\n    from data_algebra.data_ops import *\n    d = TableDescription(table_name='d', column_names=['x', 'y'])\n    print(d)</p>\n"}, {"fullname": "data_algebra.data_ops.TableDescription.__init__", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name", "column_names", "qualifiers", "sql_meta", "column_types", "head", "limit_was", "nrows"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.same_table", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.same_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.merged_rep_id", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.merged_rep_id", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.apply_to", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.get_tables", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.get_tables", "type": "function", "doc": "<p>get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.TableDescription.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "TableDescription.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.describe_table", "modulename": "data_algebra.data_ops", "qualname": "describe_table", "type": "function", "doc": "<p>:param d: pandas table to describe\n:param table_name: name of table\n:param qualifiers: optional, able qualifiers\n:param sql_meta: optional, sql meta information map\n:param column_types: optional, map of column types\n:param row_limit: how many rows to sample\n:param keep_sample: logical, if True retain head of table\n:param keep_all: logical, if True retain all of table\n:param guess_column_types: logical, if True try to infer column types\n:return: TableDescription</p>\n", "parameters": ["d", "table_name", "qualifiers", "sql_meta", "column_types", "row_limit", "keep_sample", "keep_all", "guess_column_types"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.table", "modulename": "data_algebra.data_ops", "qualname": "table", "type": "function", "doc": "<p>Capture a table for later use</p>\n\n<p>:param d: Pandas data frame to capture\n:param table_name: name for this table\n:return: a table description, with values retained</p>\n", "parameters": ["d", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.descr", "modulename": "data_algebra.data_ops", "qualname": "descr", "type": "function", "doc": "<p>Capture a named partial table as a description.</p>\n\n<p>:param kwargs: exactly one named table of the form table_name=table_value\n:return: a table description (not all values retained)</p>\n", "parameters": ["kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.data", "modulename": "data_algebra.data_ops", "qualname": "data", "type": "function", "doc": "<p>Capture a full table for later use. Exactly one of args/kwags can be set.</p>\n\n<p>:param args: at most one unnamed table of the form table_name=table_value\n:param kwargs: at most one named table of the form table_name=table_value\n:return: a table description, with all values retained</p>\n", "parameters": ["args", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ExtendNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.check_extend_window_fns", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.check_extend_window_fns", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ExtendNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ExtendNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ProjectNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ProjectNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ProjectNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "ops"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectRowsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectRowsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.SelectColumnsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "SelectColumnsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.DropColumnsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "DropColumnsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.OrderRowsNode.is_trivial_when_intermediate", "modulename": "data_algebra.data_ops", "qualname": "OrderRowsNode.is_trivial_when_intermediate", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.forbidden_columns", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.forbidden_columns", "type": "function", "doc": "<p>Determine which columns should not be in source tables</p>\n", "parameters": ["self", "forbidden"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.RenameColumnsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "RenameColumnsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.NaturalJoinNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "NaturalJoinNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "a", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConcatRowsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConcatRowsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode", "type": "class", "doc": "<p>Structure to represent the columns of a query or a table.\nAbstract base class.</p>\n"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.__init__", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "source", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.apply_to", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.columns_used_from_sources", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.columns_used_from_sources", "type": "function", "doc": "<p>Get column names used from direct source nodes when this ops is executed\nwith the using columns (None means all).</p>\n", "parameters": ["self", "using"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.to_python_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.to_python_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "indent", "strict", "print_sources"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.to_near_sql_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ConvertRecordsNode.eval_implementation", "modulename": "data_algebra.data_ops", "qualname": "ConvertRecordsNode.eval_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops.ex", "modulename": "data_algebra.data_ops", "qualname": "ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param d: data algebra pipeline or OpC container to evaluate.\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["d", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types", "modulename": "data_algebra.data_ops_types", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_types.PipeStep", "modulename": "data_algebra.data_ops_types", "qualname": "PipeStep", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_types.PipeStep.__init__", "modulename": "data_algebra.data_ops_types", "qualname": "PipeStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.PipeStep.apply_to", "modulename": "data_algebra.data_ops_types", "qualname": "PipeStep.apply_to", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other", "kwargs"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform", "type": "class", "doc": "<p>Abstract class representing ability to apply data_algebra operations.</p>\n"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.__init__", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node_name", "column_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.eval", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.eval", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames.</p>\n\n<p>:param data_map: map from table names to data frames\n:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:return: table result</p>\n", "parameters": ["self", "data_map", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.transform", "type": "function", "doc": "<p>apply self to data frame X, may or may not commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:param narrow logical, if True don't copy unexpected columns\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.act_on", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.act_on", "type": "function", "doc": "<p>apply self to data frame X, must commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.apply_to", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.add", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.add", "type": "function", "doc": "<p>other.apply_to(self)</p>\n\n<p>:param other:\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.ex", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["self", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_tables", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_tables", "type": "function", "doc": "<p>Get a dictionary of all tables used in an operator DAG,\nraise an exception if the values are not consistent.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.columns_produced", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.columns_produced", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.to_near_sql_implementation", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.extend_parsed", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.extend_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.extend", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.extend", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.project_parsed", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.project_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.project", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.natural_join", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.natural_join", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.concat_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.concat_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_rows_parsed", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_rows_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.drop_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.drop_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.select_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.select_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.rename_columns", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.rename_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.order_rows", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.order_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.convert_records", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.convert_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.map_records", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.map_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "blocks_in", "blocks_out"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.fit", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.fit_transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_feature_names", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.get_params", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.get_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.set_params", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.set_params", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_types.OperatorPlatform.inverse_transform", "modulename": "data_algebra.data_ops_types", "qualname": "OperatorPlatform.inverse_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "data_algebra.data_ops_utils", "modulename": "data_algebra.data_ops_utils", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.data_ops_utils.try_to_merge_ops", "modulename": "data_algebra.data_ops_utils", "qualname": "try_to_merge_ops", "type": "function", "doc": "<p></p>\n", "parameters": ["ops1", "ops2"], "funcdef": "def"}, {"fullname": "data_algebra.db_model", "modulename": "data_algebra.db_model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.SQLFormatOptions", "modulename": "data_algebra.db_model", "qualname": "SQLFormatOptions", "type": "class", "doc": "<p>Simple class for holding SQL formatting options</p>\n"}, {"fullname": "data_algebra.db_model.SQLFormatOptions.__init__", "modulename": "data_algebra.db_model", "qualname": "SQLFormatOptions.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "use_with", "annotate", "sql_indent", "initial_commas"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel", "modulename": "data_algebra.db_model", "qualname": "DBModel", "type": "class", "doc": "<p>A model of how SQL should be generated for a given database.</p>\n"}, {"fullname": "data_algebra.db_model.DBModel.__init__", "modulename": "data_algebra.db_model", "qualname": "DBModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "identifier_quote", "string_quote", "sql_formatters", "op_replacements", "local_data_model", "on_start", "on_end", "on_joiner", "drop_text", "string_type", "supports_with", "allow_extend_merges", "default_SQL_format_options", "union_all_term_start", "union_all_term_end"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.db_handle", "modulename": "data_algebra.db_model", "qualname": "DBModel.db_handle", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.prepare_connection", "modulename": "data_algebra.db_model", "qualname": "DBModel.prepare_connection", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.execute", "modulename": "data_algebra.db_model", "qualname": "DBModel.execute", "type": "function", "doc": "<p>:param conn: database connectionex\n:param q: sql query</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read_query", "modulename": "data_algebra.db_model", "qualname": "DBModel.read_query", "type": "function", "doc": "<p>:param conn: database connection\n:param q: sql query\n:return: query results as table</p>\n", "parameters": ["self", "conn", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_exists", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_exists", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.drop_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.drop_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table_name", "check"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.insert_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.insert_table", "type": "function", "doc": "<p>Insert a table.</p>\n\n<p>:param conn: a database connection\n:param d: a Pandas table\n:param table_name: name to give write to\n:param qualifiers: schema and such\n:param allow_overwrite logical, if True drop previous table</p>\n", "parameters": ["self", "conn", "d", "table_name", "qualifiers", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read_table", "modulename": "data_algebra.db_model", "qualname": "DBModel.read_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table_name", "qualifiers", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.read", "modulename": "data_algebra.db_model", "qualname": "DBModel.read", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "conn", "table"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_identifier", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_identifier", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "identifier"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_table_name", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_table_name", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_description"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_string", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_string", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "string"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.quote_literal", "modulename": "data_algebra.db_model", "qualname": "DBModel.quote_literal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "val"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.value_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.value_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_values_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_values_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.expr_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.expr_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expression", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.table_def_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.table_def_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_def", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.extend_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.extend_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "extend_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.project_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.project_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "project_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.select_rows_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.select_rows_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "select_rows_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.select_columns_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.select_columns_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "select_columns_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.drop_columns_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.drop_columns_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "drop_columns_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.order_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.order_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "order_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.rename_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.rename_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "rename_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.natural_join_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.natural_join_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "join_node", "using", "temp_id_source", "sql_format_options", "left_is_first"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.concat_rows_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.concat_rows_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "concat_node", "using", "temp_id_source", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.to_sql", "modulename": "data_algebra.db_model", "qualname": "DBModel.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.row_recs_to_blocks_query_str_list_pair", "modulename": "data_algebra.db_model", "qualname": "DBModel.row_recs_to_blocks_query_str_list_pair", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_spec"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.blocks_to_row_recs_query_str_list_pair", "modulename": "data_algebra.db_model", "qualname": "DBModel.blocks_to_row_recs_query_str_list_pair", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_spec"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.enc_term_", "modulename": "data_algebra.db_model", "qualname": "DBModel.enc_term_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "k", "terms"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.convert_nearsql_container_subsql_", "modulename": "data_algebra.db_model", "qualname": "DBModel.convert_nearsql_container_subsql_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "nearsql_container", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlcte_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlcte_to_sql_str_list_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqltable_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqltable_to_sql_str_list_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlunary_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlunary_to_sql_str_list_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlrawq_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlrawq_to_sql_str_list_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBModel.nearsqlbinary_to_sql_str_list_", "modulename": "data_algebra.db_model", "qualname": "DBModel.nearsqlbinary_to_sql_str_list_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants", "sql_format_options", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle", "modulename": "data_algebra.db_model", "qualname": "DBHandle", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.db_model.DBHandle.__init__", "modulename": "data_algebra.db_model", "qualname": "DBHandle.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "conn"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.read_query", "modulename": "data_algebra.db_model", "qualname": "DBHandle.read_query", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.describe_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.describe_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name", "qualifiers", "row_limit"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.to_pandas", "modulename": "data_algebra.db_model", "qualname": "DBHandle.to_pandas", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "handle", "data_map"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.execute", "modulename": "data_algebra.db_model", "qualname": "DBHandle.execute", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.drop_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.drop_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "table_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.insert_table", "modulename": "data_algebra.db_model", "qualname": "DBHandle.insert_table", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "d", "table_name", "allow_overwrite"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.to_sql", "modulename": "data_algebra.db_model", "qualname": "DBHandle.to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.query_to_csv", "modulename": "data_algebra.db_model", "qualname": "DBHandle.query_to_csv", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "q", "res_name"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.table_values_to_sql", "modulename": "data_algebra.db_model", "qualname": "DBHandle.table_values_to_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.db_model.DBHandle.close", "modulename": "data_algebra.db_model", "qualname": "DBHandle.close", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_parse", "modulename": "data_algebra.expr_parse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.expr_parse.parse_assignments_in_context", "modulename": "data_algebra.expr_parse", "qualname": "parse_assignments_in_context", "type": "function", "doc": "<p>Convert all entries of ops map to Term-expressions</p>\n\n<p>:param ops: dictionary from strings to expressions (either Terms or strings)\n:param view: a data_algebra.data_ops.ViewRepresentation\n:return:</p>\n", "parameters": ["ops", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep", "modulename": "data_algebra.expr_rep", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.expr_rep.PythonText", "modulename": "data_algebra.expr_rep", "qualname": "PythonText", "type": "class", "doc": "<p>Class for holding text representation of Python, with possible additional annotations.\nstr() method returns only the text for interoperability.</p>\n"}, {"fullname": "data_algebra.expr_rep.PythonText.__init__", "modulename": "data_algebra.expr_rep", "qualname": "PythonText.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "s", "is_in_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm", "type": "class", "doc": "<p>abstract base class, without combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.PreTerm.__init__", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.get_views", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.to_python", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool if True put parens around complex expressions that don't already have a grouper.</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.PreTerm.to_source", "modulename": "data_algebra.expr_rep", "qualname": "PreTerm.to_source", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "want_inline_parens", "dialect"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term", "modulename": "data_algebra.expr_rep", "qualname": "Term", "type": "class", "doc": "<p>Abstract intermediate class with combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.Term.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Term.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sign", "modulename": "data_algebra.expr_rep", "qualname": "Term.sign", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sin", "modulename": "data_algebra.expr_rep", "qualname": "Term.sin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cos", "modulename": "data_algebra.expr_rep", "qualname": "Term.cos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arcsin", "modulename": "data_algebra.expr_rep", "qualname": "Term.arcsin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arccos", "modulename": "data_algebra.expr_rep", "qualname": "Term.arccos", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctan", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctan", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctan2", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctan2", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sinh", "modulename": "data_algebra.expr_rep", "qualname": "Term.sinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cosh", "modulename": "data_algebra.expr_rep", "qualname": "Term.cosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.tanh", "modulename": "data_algebra.expr_rep", "qualname": "Term.tanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arcsinh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arcsinh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arccosh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arccosh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.arctanh", "modulename": "data_algebra.expr_rep", "qualname": "Term.arctanh", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.floor", "modulename": "data_algebra.expr_rep", "qualname": "Term.floor", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ceil", "modulename": "data_algebra.expr_rep", "qualname": "Term.ceil", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sum", "modulename": "data_algebra.expr_rep", "qualname": "Term.sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumprod", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumprod", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumsum", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumsum", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.exp", "modulename": "data_algebra.expr_rep", "qualname": "Term.exp", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.expm1", "modulename": "data_algebra.expr_rep", "qualname": "Term.expm1", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log", "modulename": "data_algebra.expr_rep", "qualname": "Term.log", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log10", "modulename": "data_algebra.expr_rep", "qualname": "Term.log10", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.log1p", "modulename": "data_algebra.expr_rep", "qualname": "Term.log1p", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.mod", "modulename": "data_algebra.expr_rep", "qualname": "Term.mod", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.remainder", "modulename": "data_algebra.expr_rep", "qualname": "Term.remainder", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.sqrt", "modulename": "data_algebra.expr_rep", "qualname": "Term.sqrt", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.abs", "modulename": "data_algebra.expr_rep", "qualname": "Term.abs", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.maximum", "modulename": "data_algebra.expr_rep", "qualname": "Term.maximum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.minimum", "modulename": "data_algebra.expr_rep", "qualname": "Term.minimum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.fmax", "modulename": "data_algebra.expr_rep", "qualname": "Term.fmax", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.fmin", "modulename": "data_algebra.expr_rep", "qualname": "Term.fmin", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.round", "modulename": "data_algebra.expr_rep", "qualname": "Term.round", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.around", "modulename": "data_algebra.expr_rep", "qualname": "Term.around", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.all", "modulename": "data_algebra.expr_rep", "qualname": "Term.all", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.any", "modulename": "data_algebra.expr_rep", "qualname": "Term.any", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.bfill", "modulename": "data_algebra.expr_rep", "qualname": "Term.bfill", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.count", "modulename": "data_algebra.expr_rep", "qualname": "Term.count", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cumcount", "modulename": "data_algebra.expr_rep", "qualname": "Term.cumcount", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cummax", "modulename": "data_algebra.expr_rep", "qualname": "Term.cummax", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.cummin", "modulename": "data_algebra.expr_rep", "qualname": "Term.cummin", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ffill", "modulename": "data_algebra.expr_rep", "qualname": "Term.ffill", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.first", "modulename": "data_algebra.expr_rep", "qualname": "Term.first", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.head", "modulename": "data_algebra.expr_rep", "qualname": "Term.head", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_monotonic_decreasing", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_monotonic_decreasing", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_monotonic_increasing", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_monotonic_increasing", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.last", "modulename": "data_algebra.expr_rep", "qualname": "Term.last", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.max", "modulename": "data_algebra.expr_rep", "qualname": "Term.max", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.mean", "modulename": "data_algebra.expr_rep", "qualname": "Term.mean", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.median", "modulename": "data_algebra.expr_rep", "qualname": "Term.median", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.min", "modulename": "data_algebra.expr_rep", "qualname": "Term.min", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.ngroup", "modulename": "data_algebra.expr_rep", "qualname": "Term.ngroup", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nlargest", "modulename": "data_algebra.expr_rep", "qualname": "Term.nlargest", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nsmallest", "modulename": "data_algebra.expr_rep", "qualname": "Term.nsmallest", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nth", "modulename": "data_algebra.expr_rep", "qualname": "Term.nth", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.nunique", "modulename": "data_algebra.expr_rep", "qualname": "Term.nunique", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.rank", "modulename": "data_algebra.expr_rep", "qualname": "Term.rank", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.size", "modulename": "data_algebra.expr_rep", "qualname": "Term.size", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.std", "modulename": "data_algebra.expr_rep", "qualname": "Term.std", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.unique", "modulename": "data_algebra.expr_rep", "qualname": "Term.unique", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.value_counts", "modulename": "data_algebra.expr_rep", "qualname": "Term.value_counts", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.var", "modulename": "data_algebra.expr_rep", "qualname": "Term.var", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.shift", "modulename": "data_algebra.expr_rep", "qualname": "Term.shift", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "periods"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_null", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_null", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_bad", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_bad", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.if_else", "modulename": "data_algebra.expr_rep", "qualname": "Term.if_else", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x", "y"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.is_in", "modulename": "data_algebra.expr_rep", "qualname": "Term.is_in", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.concat", "modulename": "data_algebra.expr_rep", "qualname": "Term.concat", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.coalesce", "modulename": "data_algebra.expr_rep", "qualname": "Term.coalesce", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.co_equalizer", "modulename": "data_algebra.expr_rep", "qualname": "Term.co_equalizer", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.as_int64", "modulename": "data_algebra.expr_rep", "qualname": "Term.as_int64", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.as_str", "modulename": "data_algebra.expr_rep", "qualname": "Term.as_str", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.trimstr", "modulename": "data_algebra.expr_rep", "qualname": "Term.trimstr", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "start", "stop"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.coalesce_0", "modulename": "data_algebra.expr_rep", "qualname": "Term.coalesce_0", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.datetime_to_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.datetime_to_date", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.parse_datetime", "modulename": "data_algebra.expr_rep", "qualname": "Term.parse_datetime", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.parse_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.parse_date", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.format_datetime", "modulename": "data_algebra.expr_rep", "qualname": "Term.format_datetime", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.format_date", "modulename": "data_algebra.expr_rep", "qualname": "Term.format_date", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "format"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofweek", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofweek", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofyear", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofyear", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.dayofmonth", "modulename": "data_algebra.expr_rep", "qualname": "Term.dayofmonth", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.weekofyear", "modulename": "data_algebra.expr_rep", "qualname": "Term.weekofyear", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.month", "modulename": "data_algebra.expr_rep", "qualname": "Term.month", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.quarter", "modulename": "data_algebra.expr_rep", "qualname": "Term.quarter", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.year", "modulename": "data_algebra.expr_rep", "qualname": "Term.year", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.timestamp_diff", "modulename": "data_algebra.expr_rep", "qualname": "Term.timestamp_diff", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.date_diff", "modulename": "data_algebra.expr_rep", "qualname": "Term.date_diff", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Term.base_Sunday", "modulename": "data_algebra.expr_rep", "qualname": "Term.base_Sunday", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.kop_expr", "modulename": "data_algebra.expr_rep", "qualname": "kop_expr", "type": "function", "doc": "<p>three argument expression</p>\n", "parameters": ["op", "args", "inline", "method"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value", "modulename": "data_algebra.expr_rep", "qualname": "Value", "type": "class", "doc": "<p>Abstract intermediate class with combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.Value.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Value.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "Value.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.get_views", "modulename": "data_algebra.expr_rep", "qualname": "Value.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "Value.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "Value.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Value.to_python", "modulename": "data_algebra.expr_rep", "qualname": "Value.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool if True put parens around complex expressions that don't already have a grouper.</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.UnQuotedStr", "modulename": "data_algebra.expr_rep", "qualname": "UnQuotedStr", "type": "class", "doc": "<p>str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str</p>\n\n<p>Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.</p>\n"}, {"fullname": "data_algebra.expr_rep.UnQuotedStr.__init__", "modulename": "data_algebra.expr_rep", "qualname": "UnQuotedStr.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.UnQuotedStr.str", "modulename": "data_algebra.expr_rep", "qualname": "UnQuotedStr.str", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm", "type": "class", "doc": "<p>abstract base class, without combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.ListTerm.__init__", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.get_views", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.to_python", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool if True put parens around complex expressions that don't already have a grouper.</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ListTerm.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "ListTerm.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.enc_value", "modulename": "data_algebra.expr_rep", "qualname": "enc_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference", "type": "class", "doc": "<p>class to represent referring to a column</p>\n"}, {"fullname": "data_algebra.expr_rep.ColumnReference.__init__", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view", "column_name"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.get_views", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.to_python", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool if True put parens around complex expressions that don't already have a grouper.</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.ColumnReference.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "ColumnReference.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression", "modulename": "data_algebra.expr_rep", "qualname": "Expression", "type": "class", "doc": "<p>Abstract intermediate class with combination ability</p>\n"}, {"fullname": "data_algebra.expr_rep.Expression.__init__", "modulename": "data_algebra.expr_rep", "qualname": "Expression.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "args", "params", "inline", "method"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.is_equal", "modulename": "data_algebra.expr_rep", "qualname": "Expression.is_equal", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.get_views", "modulename": "data_algebra.expr_rep", "qualname": "Expression.get_views", "type": "function", "doc": "<p>return list of unique views, expectation list is of size zero or one</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.replace_view", "modulename": "data_algebra.expr_rep", "qualname": "Expression.replace_view", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "view"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.get_column_names", "modulename": "data_algebra.expr_rep", "qualname": "Expression.get_column_names", "type": "function", "doc": "<p>Add column names to columns_seen\n:param columns_seen: set of strings\n:return:</p>\n", "parameters": ["self", "columns_seen"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.evaluate", "modulename": "data_algebra.expr_rep", "qualname": "Expression.evaluate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.Expression.to_python", "modulename": "data_algebra.expr_rep", "qualname": "Expression.to_python", "type": "function", "doc": "<p>Convert parsed expression into a string</p>\n\n<p>:param want_inline_parens: bool if True put parens around complex expressions that don't already have a grouper.</p>\n", "parameters": ["self", "want_inline_parens"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.connected_components", "modulename": "data_algebra.expr_rep", "qualname": "connected_components", "type": "function", "doc": "<p></p>\n", "parameters": ["f", "g"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.standardize_join_type", "modulename": "data_algebra.expr_rep", "qualname": "standardize_join_type", "type": "function", "doc": "<p></p>\n", "parameters": ["join_str"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.get_columns_used", "modulename": "data_algebra.expr_rep", "qualname": "get_columns_used", "type": "function", "doc": "<p></p>\n", "parameters": ["parsed_exprs"], "funcdef": "def"}, {"fullname": "data_algebra.expr_rep.implies_windowed", "modulename": "data_algebra.expr_rep", "qualname": "implies_windowed", "type": "function", "doc": "<p></p>\n", "parameters": ["parsed_exprs"], "funcdef": "def"}, {"fullname": "data_algebra.flow_text", "modulename": "data_algebra.flow_text", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.flow_text.flow_text", "modulename": "data_algebra.flow_text", "qualname": "flow_text", "type": "function", "doc": "<p>:param tokens: list or tuple of strings\n:param align_right: integer, right alignment margin\n:param sep_width: integer, size of inline separator\n:return: list of lists of strings flowing the text to the margin</p>\n", "parameters": ["tokens", "align_right", "sep_width"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql", "modulename": "data_algebra.near_sql", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.near_sql.SQLWithList", "modulename": "data_algebra.near_sql", "qualname": "SQLWithList", "type": "class", "doc": "<p>Carry an ordered sequence of SQL steps for use with a SQL WITH statement.</p>\n"}, {"fullname": "data_algebra.near_sql.SQLWithList.__init__", "modulename": "data_algebra.near_sql", "qualname": "SQLWithList.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "last_step", "previous_steps"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL", "modulename": "data_algebra.near_sql", "qualname": "NearSQL", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQL.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "is_table", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_bound_near_sql", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_bound_near_sql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQL.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQL.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer", "type": "class", "doc": "<p>NearSQL with bound in columns, force_sql, and constants decisions</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "near_sql", "columns", "force_sql", "constants"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.convert_subsql", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.convert_subsql", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLContainer.to_with_form_stub", "modulename": "data_algebra.near_sql", "qualname": "NearSQLContainer.to_with_form_stub", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLNamedEntity.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLNamedEntity.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "quoted_query_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLCommonTableExpression.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLCommonTableExpression.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLTable", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLTable.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "quoted_table_name"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLTable.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLTable.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "sub_sql", "suffix", "annotation", "mergeable", "declared_term_dependencies"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLUnaryStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLUnaryStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "terms", "quoted_query_name", "sub_sql1", "joiner", "sub_sql2", "suffix", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLBinaryStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLBinaryStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep", "type": "class", "doc": "<p>Represent SQL queries in a mostly string-form</p>\n"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep.__init__", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "prefix", "quoted_query_name", "sub_sql", "suffix", "annotation"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep.to_sql_str_list", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep.to_sql_str_list", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "force_sql", "constants", "db_model", "sql_format_options"], "funcdef": "def"}, {"fullname": "data_algebra.near_sql.NearSQLRawQStep.to_with_form", "modulename": "data_algebra.near_sql", "qualname": "NearSQLRawQStep.to_with_form", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container", "modulename": "data_algebra.op_container", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.op_container.OpC", "modulename": "data_algebra.op_container", "qualname": "OpC", "type": "class", "doc": "<p>Container that redirects to another to non-quoted notation.</p>\n"}, {"fullname": "data_algebra.op_container.OpC.__init__", "modulename": "data_algebra.op_container", "qualname": "OpC.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.set", "modulename": "data_algebra.op_container", "qualname": "OpC.set", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.start", "modulename": "data_algebra.op_container", "qualname": "OpC.start", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.get_ops", "modulename": "data_algebra.op_container", "qualname": "OpC.get_ops", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.ex", "modulename": "data_algebra.op_container", "qualname": "OpC.ex", "type": "function", "doc": "<p>Evaluate operators with respect to Pandas data frames already stored in the operator chain.</p>\n\n<p>:param data_model: adaptor to data dialect (Pandas for now)\n:param narrow: logical, if True don't copy unexpected columns\n:param allow_limited_tables: logical, if True allow execution on non-complete tables\n:return: table result</p>\n", "parameters": ["self", "data_model", "narrow", "allow_limited_tables"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.transform", "modulename": "data_algebra.op_container", "qualname": "OpC.transform", "type": "function", "doc": "<p>apply self to data frame X, may or may not commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:param narrow logical, if True don't copy unexpected columns\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.act_on", "modulename": "data_algebra.op_container", "qualname": "OpC.act_on", "type": "function", "doc": "<p>apply self to data frame X, must commute with composition</p>\n\n<p>:param X: input data frame\n:param data_model implementation to use\n:return: transformed dataframe</p>\n", "parameters": ["self", "X", "data_model"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.apply_to", "modulename": "data_algebra.op_container", "qualname": "OpC.apply_to", "type": "function", "doc": "<p>apply self to operator DAG a</p>\n\n<p>:param a: operators to apply to\n:param target_table_key: table key to replace with self, None counts as \"match all\"\n:return: new operator DAG</p>\n", "parameters": ["self", "a", "target_table_key"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.add", "modulename": "data_algebra.op_container", "qualname": "OpC.add", "type": "function", "doc": "<p>other.apply_to(self)</p>\n\n<p>:param other:\n:return:</p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.columns_produced", "modulename": "data_algebra.op_container", "qualname": "OpC.columns_produced", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.to_near_sql_implementation", "modulename": "data_algebra.op_container", "qualname": "OpC.to_near_sql_implementation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db_model", "using", "temp_id_source"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.extend_parsed", "modulename": "data_algebra.op_container", "qualname": "OpC.extend_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.extend", "modulename": "data_algebra.op_container", "qualname": "OpC.extend", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "partition_by", "order_by", "reverse"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.project_parsed", "modulename": "data_algebra.op_container", "qualname": "OpC.project_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.project", "modulename": "data_algebra.op_container", "qualname": "OpC.project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops", "group_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.natural_join", "modulename": "data_algebra.op_container", "qualname": "OpC.natural_join", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "by", "jointype", "check_all_common_keys_in_by"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.concat_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.concat_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "b", "id_column", "a_name", "b_name"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_rows_parsed", "modulename": "data_algebra.op_container", "qualname": "OpC.select_rows_parsed", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parsed_expr"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.select_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "expr"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.drop_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.drop_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_deletions"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.select_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.select_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.rename_columns", "modulename": "data_algebra.op_container", "qualname": "OpC.rename_columns", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_remapping"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.order_rows", "modulename": "data_algebra.op_container", "qualname": "OpC.order_rows", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "columns", "reverse", "limit"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.convert_records", "modulename": "data_algebra.op_container", "qualname": "OpC.convert_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "record_map"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.map_records", "modulename": "data_algebra.op_container", "qualname": "OpC.map_records", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "blocks_in", "blocks_out"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.fit", "modulename": "data_algebra.op_container", "qualname": "OpC.fit", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.fit_transform", "modulename": "data_algebra.op_container", "qualname": "OpC.fit_transform", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.OpC.get_feature_names", "modulename": "data_algebra.op_container", "qualname": "OpC.get_feature_names", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "data_algebra.op_container.Pipeline", "modulename": "data_algebra.op_container", "qualname": "Pipeline", "type": "class", "doc": "<p></p>\n"}, {"fullname": "data_algebra.op_container.Pipeline.__init__", "modulename": "data_algebra.op_container", "qualname": "Pipeline.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base", "modulename": "data_algebra.pandas_base", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.pandas_base.populate_impl_map", "modulename": "data_algebra.pandas_base", "qualname": "populate_impl_map", "type": "function", "doc": "<p></p>\n", "parameters": ["data_model"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase", "type": "class", "doc": "<p>Base class for implementing the data algebra on pandas-like APIs</p>\n"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.__init__", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pd", "presentation_model_name"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.data_frame", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.data_frame", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "arg"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.is_appropriate_data_instance", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.is_appropriate_data_instance", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "df"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.can_convert_col_to_numeric", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.can_convert_col_to_numeric", "type": "function", "doc": "<p>check if non-empty vector can convert to numeric</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.to_numeric", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.to_numeric", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x", "errors"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.isnull", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.isnull", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.bad_column_positions", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.bad_column_positions", "type": "function", "doc": "<p>for numeric vector x, return logical vector of positions that are null, NaN, infinite</p>\n", "parameters": ["self", "x"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.table_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.table_step", "type": "function", "doc": "<p>Represents a data input.</p>\n\n<p>:param op:\n:param data_map:\n:param narrow:\n:return:</p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.columns_to_frame_", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.columns_to_frame_", "type": "function", "doc": "<p>Convert a dictionary of column names to series-like objects and scalars into a Pandas data frame.</p>\n\n<p>:param cols: dictionary mapping column names to columns\n:param target_rows: number of rows we are shooting for\n:return: Pandas data frame.</p>\n", "parameters": ["self", "cols", "target_rows"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.add_data_frame_columns_to_data_frame_", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.add_data_frame_columns_to_data_frame_", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "res", "transient_new_frame"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.extend_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.extend_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.project_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.project_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.select_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.select_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.select_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.select_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.drop_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.drop_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.order_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.order_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.rename_columns_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.rename_columns_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.standardize_join_code", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.standardize_join_code", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "jointype"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.natural_join_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.natural_join_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.concat_rows_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.concat_rows_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_base.PandasModelBase.convert_records_step", "modulename": "data_algebra.pandas_base", "qualname": "PandasModelBase.convert_records_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "op", "data_map", "narrow"], "funcdef": "def"}, {"fullname": "data_algebra.pandas_model", "modulename": "data_algebra.pandas_model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.pandas_model.PandasModel", "modulename": "data_algebra.pandas_model", "qualname": "PandasModel", "type": "class", "doc": "<p>Realize the data algebra over pandas.</p>\n"}, {"fullname": "data_algebra.pandas_model.PandasModel.__init__", "modulename": "data_algebra.pandas_model", "qualname": "PandasModel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "data_algebra.parse_by_lark", "modulename": "data_algebra.parse_by_lark", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.parse_by_lark.parse_by_lark", "modulename": "data_algebra.parse_by_lark", "qualname": "parse_by_lark", "type": "function", "doc": "<p>Parse an expression in terms of data views and values.</p>\n\n<p>:param source_str: string to parse\n:param data_def: dictionary of data_algebra.expr_rep.ColumnReference\n:return: data_algebra.expr_rep.PreTerm</p>\n", "parameters": ["source_str", "data_def"], "funcdef": "def"}, {"fullname": "data_algebra.python3_lark", "modulename": "data_algebra.python3_lark", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.test_util", "modulename": "data_algebra.test_util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.test_util.formats_to_self", "modulename": "data_algebra.test_util", "qualname": "formats_to_self", "type": "function", "doc": "<p>Check a operator dag formats and parses back to itself.\nCan raise exceptions. Also checks pickling.</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:return: logical, True if formats and evals back to self</p>\n", "parameters": ["ops"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.equivalent_frames", "modulename": "data_algebra.test_util", "qualname": "equivalent_frames", "type": "function", "doc": "<p>return False if the frames are equivalent (up to column re-ordering and possible row-reordering).\nIgnores indexing.</p>\n", "parameters": ["a", "b", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.check_transform_on_handles", "modulename": "data_algebra.test_util", "qualname": "check_transform_on_handles", "type": "function", "doc": "<p>Test an operator dag produces the expected result, and parses correctly.\nAsserts if there are issues</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:param data: pd.DataFrame or map of strings to pd.DataFrame\n:param expect: pd.DataFrame\n:param db_handles:  list of database handles to use in testing\n:param float_tol: passed to equivalent_frames()\n:param check_column_order: passed to equivalent_frames()\n:param cols_case_sensitive: passed to equivalent_frames()\n:param check_row_order: passed to equivalent_frames()\n:param check_parse: if True check expression parses/formats to self\n:param local_data_model: optional alternate evaluation model\n:param empty_produces_empty: logical, if true assume emtpy inputs should produce empty output\n:return: None, assert if there is an issue</p>\n", "parameters": ["ops", "data", "expect", "db_handles", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "check_parse", "local_data_model", "empty_produces_empty"], "funcdef": "def"}, {"fullname": "data_algebra.test_util.get_test_dbs", "modulename": "data_algebra.test_util", "qualname": "get_test_dbs", "type": "function", "doc": "<p>handles connected to databases for testing.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "data_algebra.test_util.check_transform", "modulename": "data_algebra.test_util", "qualname": "check_transform", "type": "function", "doc": "<p>Test an operator dag produces the expected result, and parses correctly.\nAssert if there are issues.</p>\n\n<p>:param ops: data_algebra.data_ops.ViewRepresentation\n:param data: pd.DataFrame or map of strings to pd.DataFrame\n:param expect: pd.DataFrame\n:param float_tol: passed to equivalent_frames()\n:param check_column_order: passed to equivalent_frames()\n:param cols_case_sensitive: passed to equivalent_frames()\n:param check_row_order: passed to equivalent_frames()\n:param check_parse: if True check expression parses/formats to self\n:param models_to_skip: None or set of model names to skip testing\n:param empty_produces_empty: logical, if true assume emtpy inputs should produce empty output\n:return: nothing</p>\n", "parameters": ["ops", "data", "expect", "float_tol", "check_column_order", "cols_case_sensitive", "check_row_order", "check_parse", "models_to_skip", "empty_produces_empty"], "funcdef": "def"}, {"fullname": "data_algebra.util", "modulename": "data_algebra.util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "data_algebra.util.pandas_to_example_str", "modulename": "data_algebra.util", "qualname": "pandas_to_example_str", "type": "function", "doc": "<p></p>\n", "parameters": ["obj", "local_data_model"], "funcdef": "def"}, {"fullname": "data_algebra.util.table_is_keyed_by_columns", "modulename": "data_algebra.util", "qualname": "table_is_keyed_by_columns", "type": "function", "doc": "<p>:param table: pandas DataFrame\n:param column_names: list of column names\n:return: True if rows are uniquely keyed by values in named columns</p>\n", "parameters": ["table", "column_names"], "funcdef": "def"}, {"fullname": "data_algebra.util.map_type_to_canonical", "modulename": "data_algebra.util", "qualname": "map_type_to_canonical", "type": "function", "doc": "<p></p>\n", "parameters": ["v"], "funcdef": "def"}, {"fullname": "data_algebra.util.guess_carried_scalar_type", "modulename": "data_algebra.util", "qualname": "guess_carried_scalar_type", "type": "function", "doc": "<p>Guess the type of a column or scalar.</p>\n\n<p>:param col: column or scalar to inspect\n:return: type of first non-None entry, if any , else type(None)</p>\n", "parameters": ["col"], "funcdef": "def"}, {"fullname": "data_algebra.util.guess_column_types", "modulename": "data_algebra.util", "qualname": "guess_column_types", "type": "function", "doc": "<p>Guess column types as type of first non-missing value.\nWill not return series types, as some pandas data frames with non-trivial indexing report this type.</p>\n\n<p>:param d: pandas.DataFrame\n:param columns: list of columns to check, if None all columns are checked\n:return: map of column names to guessed types, empty dict if any column guess fails</p>\n", "parameters": ["d", "columns"], "funcdef": "def"}, {"fullname": "data_algebra.util.compatible_types", "modulename": "data_algebra.util", "qualname": "compatible_types", "type": "function", "doc": "<p></p>\n", "parameters": ["types_seen"], "funcdef": "def"}, {"fullname": "data_algebra.util.check_columns_appear_compatible", "modulename": "data_algebra.util", "qualname": "check_columns_appear_compatible", "type": "function", "doc": "<p>Check if columns have compatible types</p>\n\n<p>:param d_left: pandas dataframe to check\n:param d_right: pandas dataframe to check\n:param columns: columns to check, None means check all columns\n:return: None if compatible, else dictionary of mismatches</p>\n", "parameters": ["d_left", "d_right", "columns"], "funcdef": "def"}]

error (n)
op: arctan2, op_class: e, example expression: x.arctan2(y), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "y"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arctan2(y)'})
   "row_id" ,
   ARCTAN2("x", "y") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': no such function: ARCTAN2


difference (w)
op: datetime_to_date, op_class: e, example expression: datetime_col_0.datetime_to_date(), db: SQLiteModel
Pandas result (expectation):
   row_id  new_column
0       0  2010-01-01
1       1  2030-04-05
2       2  2010-01-01
3       3  2030-04-05
DB result:
   row_id  new_column
0       0  2010-01-01
1       1  2030-04-05
2       2  2010-01-01
3       3  2030-04-05
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "datetime_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'datetime_col_0.datetime_to_date()'})
   "row_id" ,
   DATE("datetime_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"



error (n)
op: parse_date, op_class: e, example expression: str_date_col.parse_date(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "str_date_col"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': "str_date_col.parse_date('percentY-percentm-percentd')"})
   "row_id" ,
   PARSE_DATE('%Y-%m-%d', "str_date_col") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': no such function: PARSE_DATE


error (n)
op: parse_datetime, op_class: e, example expression: str_datetime_col.parse_datetime(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "str_datetime_col"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': "str_datetime_col.parse_datetime('percentY-percentm-percentd percentH:percentM:percentS')"})
   "row_id" ,
   PARSE_DATETIME('%Y-%m-%d %H:%M:%S', "str_datetime_col") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': no such function: PARSE_DATETIME


error (n)
op: format_datetime, op_class: e, example expression: datetime_col_0.format_datetime(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "datetime_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': "datetime_col_0.format_datetime('percentY-percentm-percentd percentH:percentM:percentS')"})
   "row_id" ,
   FORMAT_DATETIME('%Y-%m-%d %H:%M:%S', "datetime_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': no such function: FORMAT_DATETIME


error (n)
op: format_date, op_class: e, example expression: date_col_0.format_date(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': "date_col_0.format_date('percentY-percentm-percentd')"})
   "row_id" ,
   FORMAT_DATE('%Y-%m-%d', "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': no such function: FORMAT_DATE


error (n)
op: dayofweek, op_class: e, example expression: date_col_0.dayofweek(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.dayofweek()'})
   "row_id" ,
   EXTRACT(DAYOFWEEK FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: dayofyear, op_class: e, example expression: date_col_0.dayofyear(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.dayofyear()'})
   "row_id" ,
   EXTRACT(DAYOFYEAR FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: dayofmonth, op_class: e, example expression: date_col_0.dayofmonth(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.dayofmonth()'})
   "row_id" ,
   EXTRACT(DAY FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: weekofyear, op_class: e, example expression: date_col_0.weekofyear(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.weekofyear()'})
   "row_id" ,
   EXTRACT(WEEK FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: month, op_class: e, example expression: date_col_0.month(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.month()'})
   "row_id" ,
   EXTRACT(MONTH FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: quarter, op_class: e, example expression: date_col_0.quarter(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.quarter()'})
   "row_id" ,
   EXTRACT(QUARTER FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: year, op_class: e, example expression: date_col_0.year(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.year()'})
   "row_id" ,
   EXTRACT(YEAR FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: timestamp_diff, op_class: e, example expression: datetime_col_0.timestamp_diff(datetime_col_1), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "datetime_col_0" ,
   "datetime_col_1"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'datetime_col_0.timestamp_diff(datetime_col_1)'})
   "row_id" ,
   TIMESTAMP_DIFF("datetime_col_0", "datetime_col_1", SECOND) AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': no such column: SECOND


error (n)
op: date_diff, op_class: e, example expression: date_col_0.date_diff(date_col_1), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0" ,
   "date_col_1"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.date_diff(date_col_1)'})
   "row_id" ,
   TIMESTAMP_DIFF("date_col_0", "date_col_1", DAY) AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': no such column: DAY


error (n)
op: base_Sunday, op_class: e, example expression: date_col_1.base_Sunday(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_1"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_1.base_Sunday()'})
   "row_id" ,
   DATE_SUB("date_col_1", INTERVAL (EXTRACT(DAYOFWEEK FROM "date_col_1") - 1) DAY) AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
': near "FROM": syntax error


error (n)
op: _ngroup, op_class: g, example expression: _ngroup(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': '_ngroup()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   NGROUP() OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': no such function: NGROUP


error (n)
op: median, op_class: g, example expression: x.median(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.median()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   MEDIAN("x") OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': MEDIAN() may not be used as a window function


error (n)
op: std, op_class: g, example expression: x.std(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.std()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   STD("x") OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': STD() may not be used as a window function


error (n)
op: var, op_class: g, example expression: x.var(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.var()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   VAR("x") OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': VAR() may not be used as a window function


error (n)
op: nunique, op_class: g, example expression: x.nunique(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.nunique()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   COUNT(DISTINCT ("x")) OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': DISTINCT is not supported for window functions


difference (w)
op: _count, op_class: g, example expression: _count(), db: SQLiteModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           1
1    a       1           2
2    b       2           1
3  ccc       3           1
DB result:
     g  row_id  new_column
0    a       0           2
1    a       1           2
2    b       2           1
3  ccc       3           1
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': '_count()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   SUM(1) OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"



error (n)
op: bfill, op_class: w, example expression: z.bfill(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "z" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'z.bfill()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   BFILL("z") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': no such function: BFILL


error (n)
op: ffill, op_class: w, example expression: z.ffill(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "z" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'z.ffill()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   FFILL("z") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': no such function: FFILL


error (n)
op: first, op_class: w, example expression: x.first(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.first()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   FIRST("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': no such function: FIRST


error (n)
op: last, op_class: w, example expression: x.last(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.last()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   LAST("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': no such function: LAST


error (n)
op: rank, op_class: w, example expression: x.rank(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.rank()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   RANK("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': wrong number of arguments to function RANK()


error (n)
op: cumprod, op_class: w, example expression: x.cumprod(), db: SQLiteModel
caught: Execution failed on sql '-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.cumprod()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   PROD("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
': no such function: PROD


difference (w)
op: cumcount, op_class: w, example expression: z.cumcount(), db: SQLiteModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           0
1    a       1           1
2    b       2           0
3  ccc       3           0
DB result:
     g  row_id  new_column
0    a       0           1
1    a       1           1
2    b       2           1
3  ccc       3           0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SQLiteModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "z" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'z.cumcount()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   SUM(CASE WHEN "z" IS NOT NULL THEN 1 ELSE 0 END) OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"



error (n)
op: arcsin, op_class: e, example expression: x.arcsin(), db: BigQueryModel
caught: 400 Function not found: ARCSIN; Did you mean asin? at [16:4]

Location: US
Job ID: 238558e9-306f-4304-938e-fe387eab191d



error (n)
op: arccos, op_class: e, example expression: x.arccos(), db: BigQueryModel
caught: 400 Function not found: ARCCOS; Did you mean acos? at [16:4]

Location: US
Job ID: fc8d27b1-da4d-4348-b3e2-f6bf395bfb14



error (n)
op: arctan, op_class: e, example expression: x.arctan(), db: BigQueryModel
caught: 400 Function not found: ARCTAN; Did you mean atan? at [16:4]

Location: US
Job ID: 473bef45-2322-4cab-b63f-00636d4a2704



error (n)
op: arctan2, op_class: e, example expression: x.arctan2(y), db: BigQueryModel
caught: 400 Function not found: ARCTAN2; Did you mean atan2? at [17:4]

Location: US
Job ID: d89c110b-88c7-4ff1-8edf-4d2f4fecf575



error (n)
op: arcsinh, op_class: e, example expression: x.arcsinh(), db: BigQueryModel
caught: 400 Function not found: ARCSINH; Did you mean asinh? at [16:4]

Location: US
Job ID: 991a7d88-91fe-4af2-8945-c8f0c213f73d



error (n)
op: arccosh, op_class: e, example expression: x.arccosh(), db: BigQueryModel
caught: 400 Function not found: ARCCOSH; Did you mean acosh? at [16:4]

Location: US
Job ID: b39b5fe6-f0bd-4637-b95e-43d20565bf07



error (n)
op: arctanh, op_class: e, example expression: x.arctanh(), db: BigQueryModel
caught: 400 Function not found: ARCTANH; Did you mean atanh? at [16:4]

Location: US
Job ID: b0973290-8bde-4990-bb68-870d159437a7



error (n)
op: expm1, op_class: e, example expression: y.expm1(), db: BigQueryModel
caught: 400 Function not found: EXPM1; Did you mean exp? at [16:4]

Location: US
Job ID: 799f390b-47f9-46fe-a785-fbfd05cb4664



error (n)
op: log1p, op_class: e, example expression: x.log1p(), db: BigQueryModel
caught: 400 Function not found: LOG1P; Did you mean log10? at [16:4]

Location: US
Job ID: f63ba6fb-1c63-4019-b073-4d67595d5779



error (n)
op: _ngroup, op_class: g, example expression: _ngroup(), db: BigQueryModel
caught: 400 Function not found: NGROUP at [17:4]

Location: US
Job ID: e8dfcdb8-ac87-45d3-b1f0-91978a68dc7e



difference (w)
op: _count, op_class: g, example expression: _count(), db: BigQueryModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           1
1    a       1           2
2    b       2           1
3  ccc       3           1
DB result:
     g  row_id  new_column
0    a       0           2
1    a       1           2
2    b       2           1
3  ccc       3           1
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: BigQueryModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `g`
  FROM
   `data-algebra-test.test_1.d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': '_count()'}, partition_by=['g'])
   `g` ,
   `row_id` ,
   SUM(1) OVER ( PARTITION BY `g`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`



error (n)
op: median, op_class: p, example expression: x.median(), db: BigQueryModel
caught: 400 percentile_cont aggregate function is not supported.

Location: US
Job ID: c96cf6a2-4336-4e85-9e12-567578e42597



error (n)
op: bfill, op_class: w, example expression: z.bfill(), db: BigQueryModel
caught: 400 Function not found: BFILL at [18:4]

Location: US
Job ID: 9a5fe092-e1b2-41d0-bd32-397bfc9a1c1e



error (n)
op: ffill, op_class: w, example expression: z.ffill(), db: BigQueryModel
caught: 400 Function not found: FFILL at [18:4]

Location: US
Job ID: de3a0b56-8f7c-40f1-873a-d2af68a0bcb2



error (n)
op: first, op_class: w, example expression: x.first(), db: BigQueryModel
caught: 400 Function not found: FIRST at [18:4]

Location: US
Job ID: 1503ef50-0a46-4988-b7a4-b9b727439059



error (n)
op: last, op_class: w, example expression: x.last(), db: BigQueryModel
caught: 400 Function not found: LAST; Did you mean least? at [18:4]

Location: US
Job ID: d27333b9-1a20-48dd-a7bd-7d85ec27b832



error (n)
op: rank, op_class: w, example expression: x.rank(), db: BigQueryModel
caught: 400 Number of arguments does not match for analytic function RANK. Supported signature: RANK() at [18:4]

Location: US
Job ID: feda1d09-e1e2-471f-a464-20e30e5b7d5d



error (n)
op: cumprod, op_class: w, example expression: x.cumprod(), db: BigQueryModel
caught: 400 Function not found: PROD at [18:4]

Location: US
Job ID: f4904c67-3a03-48ff-910b-9bd334c63544



difference (w)
op: cumcount, op_class: w, example expression: z.cumcount(), db: BigQueryModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           0
1    a       1           1
2    b       2           0
3  ccc       3           0
DB result:
     g  row_id  new_column
0    a       0           1
1    a       1           1
2    b       2           1
3  ccc       3           0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: BigQueryModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z` ,
   `g`
  FROM
   `data-algebra-test.test_1.d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.cumcount()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   SUM(CASE WHEN `z` IS NOT NULL THEN 1 ELSE 0 END) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`



error (n)
op: arcsin, op_class: e, example expression: x.arcsin(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function arcsin(double precision) does not exist
LINE 16:    ARCSIN("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arcsin()'})
   "row_id" ,
   ARCSIN("x") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: arccos, op_class: e, example expression: x.arccos(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function arccos(double precision) does not exist
LINE 16:    ARCCOS("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arccos()'})
   "row_id" ,
   ARCCOS("x") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: arctan, op_class: e, example expression: x.arctan(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function arctan(double precision) does not exist
LINE 16:    ARCTAN("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arctan()'})
   "row_id" ,
   ARCTAN("x") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: arctan2, op_class: e, example expression: x.arctan2(y), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function arctan2(double precision, double precision) does not exist
LINE 17:    ARCTAN2("x", "y") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "y"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arctan2(y)'})
   "row_id" ,
   ARCTAN2("x", "y") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: arcsinh, op_class: e, example expression: x.arcsinh(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function arcsinh(double precision) does not exist
LINE 16:    ARCSINH("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arcsinh()'})
   "row_id" ,
   ARCSINH("x") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: arccosh, op_class: e, example expression: x.arccosh(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function arccosh(double precision) does not exist
LINE 16:    ARCCOSH("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arccosh()'})
   "row_id" ,
   ARCCOSH("x") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: arctanh, op_class: e, example expression: x.arctanh(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function arctanh(double precision) does not exist
LINE 16:    ARCTANH("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.arctanh()'})
   "row_id" ,
   ARCTANH("x") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: expm1, op_class: e, example expression: y.expm1(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function expm1(double precision) does not exist
LINE 16:    EXPM1("y") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "y"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'y.expm1()'})
   "row_id" ,
   EXPM1("y") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: log1p, op_class: e, example expression: x.log1p(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function log1p(double precision) does not exist
LINE 16:    LOG1P("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.log1p()'})
   "row_id" ,
   LOG1P("x") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: parse_date, op_class: e, example expression: str_date_col.parse_date(), db: PostgreSQLModel
caught: dict is not a sequence


error (n)
op: parse_datetime, op_class: e, example expression: str_datetime_col.parse_datetime(), db: PostgreSQLModel
caught: dict is not a sequence


error (n)
op: format_datetime, op_class: e, example expression: datetime_col_0.format_datetime(), db: PostgreSQLModel
caught: dict is not a sequence


error (n)
op: format_date, op_class: e, example expression: date_col_0.format_date(), db: PostgreSQLModel
caught: dict is not a sequence


error (n)
op: dayofweek, op_class: e, example expression: date_col_0.dayofweek(), db: PostgreSQLModel
caught: (psycopg2.errors.InvalidParameterValue) timestamp units "dayofweek" not recognized

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.dayofweek()'})
   "row_id" ,
   EXTRACT(DAYOFWEEK FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/9h9h)


error (n)
op: dayofyear, op_class: e, example expression: date_col_0.dayofyear(), db: PostgreSQLModel
caught: (psycopg2.errors.InvalidParameterValue) timestamp units "dayofyear" not recognized

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.dayofyear()'})
   "row_id" ,
   EXTRACT(DAYOFYEAR FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/9h9h)


difference (w)
op: weekofyear, op_class: e, example expression: date_col_0.weekofyear(), db: PostgreSQLModel
Pandas result (expectation):
   row_id  new_column
0       0           1
1       1          13
2       2           1
3       3          13
DB result:
   row_id  new_column
0       0        52.0
1       1        14.0
2       2        52.0
3       3        14.0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.weekofyear()'})
   "row_id" ,
   EXTRACT(WEEK FROM "date_col_0") AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"



error (n)
op: timestamp_diff, op_class: e, example expression: datetime_col_0.timestamp_diff(datetime_col_1), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedColumn) column "second" does not exist
LINE 17: ...IMESTAMP_DIFF("datetime_col_0", "datetime_col_1", SECOND) AS...
                                                              ^

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "datetime_col_0" ,
   "datetime_col_1"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'datetime_col_0.timestamp_diff(datetime_col_1)'})
   "row_id" ,
   TIMESTAMP_DIFF("datetime_col_0", "datetime_col_1", SECOND) AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: date_diff, op_class: e, example expression: date_col_0.date_diff(date_col_1), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedColumn) column "day" does not exist
LINE 17:    TIMESTAMP_DIFF("date_col_0", "date_col_1", DAY) AS "new_c...
                                                       ^

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_0" ,
   "date_col_1"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.date_diff(date_col_1)'})
   "row_id" ,
   TIMESTAMP_DIFF("date_col_0", "date_col_1", DAY) AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: base_Sunday, op_class: e, example expression: date_col_1.base_Sunday(), db: PostgreSQLModel
caught: (psycopg2.errors.SyntaxError) syntax error at or near "EXTRACT"
LINE 16:    DATE_SUB("date_col_1", INTERVAL (EXTRACT(DAYOFWEEK FROM "...
                                             ^

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "date_col_1"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'date_col_1.base_Sunday()'})
   "row_id" ,
   DATE_SUB("date_col_1", INTERVAL (EXTRACT(DAYOFWEEK FROM "date_col_1") - 1) DAY) AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: _ngroup, op_class: g, example expression: _ngroup(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function ngroup() does not exist
LINE 17:    NGROUP() OVER ( PARTITION BY "g"  )  AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': '_ngroup()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   NGROUP() OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: median, op_class: g, example expression: x.median(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function median(double precision) does not exist
LINE 18:    MEDIAN("x") OVER ( PARTITION BY "g"  )  AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.median()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   MEDIAN("x") OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: nunique, op_class: g, example expression: x.nunique(), db: PostgreSQLModel
caught: (psycopg2.errors.FeatureNotSupported) DISTINCT is not implemented for window functions
LINE 18:    COUNT(DISTINCT ("x")) OVER ( PARTITION BY "g"  )  AS "new...
            ^

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.nunique()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   COUNT(DISTINCT ("x")) OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/tw8g)


difference (w)
op: _count, op_class: g, example expression: _count(), db: PostgreSQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           1
1    a       1           2
2    b       2           1
3  ccc       3           1
DB result:
     g  row_id  new_column
0    a       0           2
1    a       1           2
2    b       2           1
3  ccc       3           1
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': '_count()'}, partition_by=['g'])
   "g" ,
   "row_id" ,
   SUM(1) OVER ( PARTITION BY "g"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"



error (n)
op: median, op_class: p, example expression: x.median(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function median(double precision) does not exist
LINE 16:    MEDIAN("x") AS "new_column"
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "g" ,
   "x"
  FROM
   "d"
 ) ,
 "project_1" AS (
  SELECT  -- .project({ 'new_column': 'x.median()'}, group_by=['g'])
   "g" ,
   MEDIAN("x") AS "new_column"
  FROM
   "table_reference_0"
  GROUP BY
   "g"
 )
SELECT  -- .order_rows(['g'])
 *
FROM
 "project_1"
ORDER BY
 "g"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: bfill, op_class: w, example expression: z.bfill(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function bfill(double precision) does not exist
LINE 18:    BFILL("z") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  ...
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "z" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'z.bfill()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   BFILL("z") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: ffill, op_class: w, example expression: z.ffill(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function ffill(double precision) does not exist
LINE 18:    FFILL("z") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  ...
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "z" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'z.ffill()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   FFILL("z") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: first, op_class: w, example expression: x.first(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function first(double precision) does not exist
LINE 18:    FIRST("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  ...
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.first()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   FIRST("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: last, op_class: w, example expression: x.last(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function last(double precision) does not exist
LINE 18:    LAST("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  A...
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.last()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   LAST("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: rank, op_class: w, example expression: x.rank(), db: PostgreSQLModel
caught: (psycopg2.errors.WrongObjectType) WITHIN GROUP is required for ordered-set aggregate rank
LINE 18:    RANK("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  A...
            ^

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.rank()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   RANK("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: cumprod, op_class: w, example expression: x.cumprod(), db: PostgreSQLModel
caught: (psycopg2.errors.UndefinedFunction) function prod(double precision) does not exist
LINE 18:    PROD("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  A...
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "x" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'x.cumprod()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   PROD("x") OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"
]
(Background on this error at: https://sqlalche.me/e/14/f405)


difference (w)
op: cumcount, op_class: w, example expression: z.cumcount(), db: PostgreSQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           0
1    a       1           1
2    b       2           0
3  ccc       3           0
DB result:
     g  row_id  new_column
0    a       0           1
1    a       1           1
2    b       2           1
3  ccc       3           0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: PostgreSQLModel 1.4.1
--       string quote: '
--   identifier quote: "
WITH
 "table_reference_0" AS (
  SELECT
   "row_id" ,
   "z" ,
   "g"
  FROM
   "d"
 ) ,
 "extend_1" AS (
  SELECT  -- .extend({ 'new_column': 'z.cumcount()'}, partition_by=['g'], order_by=['row_id'])
   "g" ,
   "row_id" ,
   SUM(CASE WHEN "z" IS NOT NULL THEN 1 ELSE 0 END) OVER ( PARTITION BY "g" ORDER BY "row_id"  )  AS "new_column"
  FROM
   "table_reference_0"
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 "extend_1"
ORDER BY
 "g" ,
 "row_id"



error (n)
op: arcsin, op_class: e, example expression: x.arcsin(), db: SparkSQLModel
caught: Undefined function: 'ARCSIN'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: arccos, op_class: e, example expression: x.arccos(), db: SparkSQLModel
caught: Undefined function: 'ARCCOS'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: arctan, op_class: e, example expression: x.arctan(), db: SparkSQLModel
caught: Undefined function: 'ARCTAN'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: arctan2, op_class: e, example expression: x.arctan2(y), db: SparkSQLModel
caught: Undefined function: 'ARCTAN2'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 17 pos 3


error (n)
op: arcsinh, op_class: e, example expression: x.arcsinh(), db: SparkSQLModel
caught: Undefined function: 'ARCSINH'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: arccosh, op_class: e, example expression: x.arccosh(), db: SparkSQLModel
caught: Undefined function: 'ARCCOSH'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: arctanh, op_class: e, example expression: x.arctanh(), db: SparkSQLModel
caught: Undefined function: 'ARCTANH'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


difference (w)
op: floor, op_class: e, example expression: z.floor(), db: SparkSQLModel
Pandas result (expectation):
   row_id  new_column
0       0         1.0
1       1         NaN
2       2        -3.0
3       3         NaN
DB result:
   row_id  new_column
0       0           1
1       1           0
2       2          -3
3       3           0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.floor()'})
   `row_id` ,
   FLOOR(`z`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`



difference (w)
op: ceil, op_class: e, example expression: z.ceil(), db: SparkSQLModel
Pandas result (expectation):
   row_id  new_column
0       0         2.0
1       1         NaN
2       2        -2.0
3       3         NaN
DB result:
   row_id  new_column
0       0           2
1       1           0
2       2          -2
3       3           0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.ceil()'})
   `row_id` ,
   CEILING(`z`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`



difference (w)
op: is_null, op_class: e, example expression: z.is_null(), db: SparkSQLModel
Pandas result (expectation):
   row_id  new_column
0       0       False
1       1        True
2       2       False
3       3        True
DB result:
   row_id  new_column
0       0       False
1       1       False
2       2       False
3       3       False
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.is_null()'})
   `row_id` ,
   (`z` IS NULL) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`



error (n)
op: as_int64, op_class: e, example expression: y.as_int64(), db: SparkSQLModel
caught: 
DataType int64 is not supported.(line 16, pos 15)

== SQL ==
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `y`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'y.as_int64()'})
   `row_id` ,
   CAST(`y` AS INT64) AS `new_column`
---------------^^^
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`



error (n)
op: parse_date, op_class: e, example expression: str_date_col.parse_date(), db: SparkSQLModel
caught: Undefined function: 'PARSE_DATE'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: parse_datetime, op_class: e, example expression: str_datetime_col.parse_datetime(), db: SparkSQLModel
caught: Undefined function: 'PARSE_DATETIME'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: format_datetime, op_class: e, example expression: datetime_col_0.format_datetime(), db: SparkSQLModel
caught: Undefined function: 'FORMAT_DATETIME'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: format_date, op_class: e, example expression: date_col_0.format_date(), db: SparkSQLModel
caught: Undefined function: 'FORMAT_DATE'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


error (n)
op: dayofyear, op_class: e, example expression: date_col_0.dayofyear(), db: SparkSQLModel
caught: Literals of type 'DAYOFYEAR' are currently not supported for the date type.; line 16 pos 3


difference (w)
op: weekofyear, op_class: e, example expression: date_col_0.weekofyear(), db: SparkSQLModel
Pandas result (expectation):
   row_id  new_column
0       0           1
1       1          13
2       2           1
3       3          13
DB result:
   row_id  new_column
0       0          52
1       1          14
2       2          52
3       3          14
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `date_col_0`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.weekofyear()'})
   `row_id` ,
   EXTRACT(WEEK FROM `date_col_0`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`



error (n)
op: timestamp_diff, op_class: e, example expression: datetime_col_0.timestamp_diff(datetime_col_1), db: SparkSQLModel
caught: Undefined function: 'TIMESTAMP_DIFF'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 17 pos 3


error (n)
op: date_diff, op_class: e, example expression: date_col_0.date_diff(date_col_1), db: SparkSQLModel
caught: Undefined function: 'TIMESTAMP_DIFF'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 17 pos 3


error (n)
op: base_Sunday, op_class: e, example expression: date_col_1.base_Sunday(), db: SparkSQLModel
caught: 
no viable alternative at input 'WITH\n `table_reference_0` AS (\n  SELECT\n   `row_id` ,\n   `date_col_1`\n  FROM\n   `d`\n ) ,\n `extend_1` AS (\n  SELECT  -- .extend({ 'new_column': 'date_col_1.base_Sunday()'})\n   `row_id` ,\n   DATE_SUB(`date_col_1`, INTERVAL (EXTRACT(DAYOFWEEK FROM `date_col_1`) - 1) DAY'(line 16, pos 78)

== SQL ==
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `date_col_1`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'date_col_1.base_Sunday()'})
   `row_id` ,
   DATE_SUB(`date_col_1`, INTERVAL (EXTRACT(DAYOFWEEK FROM `date_col_1`) - 1) DAY) AS `new_column`
------------------------------------------------------------------------------^^^
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`



error (n)
op: _ngroup, op_class: g, example expression: _ngroup(), db: SparkSQLModel
caught: Undefined function: 'NGROUP'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 17 pos 3


error (n)
op: median, op_class: g, example expression: x.median(), db: SparkSQLModel
caught: Undefined function: 'MEDIAN'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 18 pos 3


error (n)
op: nunique, op_class: g, example expression: x.nunique(), db: SparkSQLModel
caught: Distinct window functions are not supported: count(distinct x#4) windowspecdefinition(g#7, specifiedwindowframe(RowFrame, unboundedpreceding$(), unboundedfollowing$()));
Sort [g#7 ASC NULLS FIRST, row_id#0L ASC NULLS FIRST], true
+- Project [g#7, row_id#0L, new_column#2712L]
   +- SubqueryAlias extend_1
      +- Project [g#7, row_id#0L, new_column#2712L]
         +- Project [g#7, row_id#0L, x#4, new_column#2712L, new_column#2712L]
            +- Window [count(distinct x#4) windowspecdefinition(g#7, specifiedwindowframe(RowFrame, unboundedpreceding$(), unboundedfollowing$())) AS new_column#2712L], [g#7]
               +- Project [g#7, row_id#0L, x#4]
                  +- SubqueryAlias table_reference_0
                     +- Project [row_id#0L, x#4, g#7]
                        +- SubqueryAlias d
                           +- LogicalRDD [row_id#0L, a#1, b#2, q#3L, x#4, y#5, z#6, g#7, s2#8, str_datetime_col#9, str_date_col#10, datetime_col_0#11, datetime_col_1#12, date_col_0#13, date_col_1#14], false



difference (w)
op: count, op_class: g, example expression: z.count(), db: SparkSQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           1
1    a       1           1
2    b       2           1
3  ccc       3           0
DB result:
     g  row_id  new_column
0    a       0           2
1    a       1           2
2    b       2           1
3  ccc       3           1
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.count()'}, partition_by=['g'])
   `g` ,
   `row_id` ,
   SUM(CASE WHEN `z` IS NOT NULL THEN 1 ELSE 0 END) OVER ( PARTITION BY `g`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`



difference (w)
op: _count, op_class: g, example expression: _count(), db: SparkSQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           1
1    a       1           2
2    b       2           1
3  ccc       3           1
DB result:
     g  row_id  new_column
0    a       0           2
1    a       1           2
2    b       2           1
3  ccc       3           1
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': '_count()'}, partition_by=['g'])
   `g` ,
   `row_id` ,
   SUM(1) OVER ( PARTITION BY `g`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`



error (n)
op: median, op_class: p, example expression: x.median(), db: SparkSQLModel
caught: Undefined function: 'MEDIAN'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 16 pos 3


difference (w)
op: count, op_class: p, example expression: z.count(), db: SparkSQLModel
Pandas result (expectation):
     g  new_column
0    a           1
1    b           1
2  ccc           0
DB result:
     g  new_column
0    a           2
1    b           1
2  ccc           1
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `z` ,
   `g`
  FROM
   `d`
 ) ,
 `project_1` AS (
  SELECT  -- .project({ 'new_column': 'z.count()'}, group_by=['g'])
   `g` ,
   SUM(CASE WHEN `z` IS NOT NULL THEN 1 ELSE 0 END) AS `new_column`
  FROM
   `table_reference_0`
  GROUP BY
   `g`
 )
SELECT  -- .order_rows(['g'])
 *
FROM
 `project_1`
ORDER BY
 `g`



error (n)
op: bfill, op_class: w, example expression: z.bfill(), db: SparkSQLModel
caught: Undefined function: 'BFILL'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 18 pos 3


error (n)
op: ffill, op_class: w, example expression: z.ffill(), db: SparkSQLModel
caught: Undefined function: 'FFILL'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 18 pos 3


difference (w)
op: last, op_class: w, example expression: x.last(), db: SparkSQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0         0.2
1    a       1         0.2
2    b       2         0.3
3  ccc       3         0.4
DB result:
     g  row_id  new_column
0    a       0         0.1
1    a       1         0.2
2    b       2         0.3
3  ccc       3         0.4
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.last()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   LAST(`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`



error (n)
op: cumprod, op_class: w, example expression: x.cumprod(), db: SparkSQLModel
caught: Undefined function: 'PROD'. This function is neither a registered temporary function nor a permanent function registered in the database 'default'.; line 18 pos 3


difference (w)
op: cumcount, op_class: w, example expression: z.cumcount(), db: SparkSQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           0
1    a       1           1
2    b       2           0
3  ccc       3           0
DB result:
     g  row_id  new_column
0    a       0           1
1    a       1           2
2    b       2           1
3  ccc       3           1
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: SparkSQLModel 1.4.1
--       string quote: "
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.cumcount()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   SUM(CASE WHEN `z` IS NOT NULL THEN 1 ELSE 0 END) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`



error (n)
op: arcsin, op_class: e, example expression: x.arcsin(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.ARCSIN does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.arcsin()'})
   `row_id` ,
   ARCSIN(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: arccos, op_class: e, example expression: x.arccos(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.ARCCOS does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.arccos()'})
   `row_id` ,
   ARCCOS(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: arctan, op_class: e, example expression: x.arctan(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.ARCTAN does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.arctan()'})
   `row_id` ,
   ARCTAN(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: arctan2, op_class: e, example expression: x.arctan2(y), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.ARCTAN2 does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `y`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.arctan2(y)'})
   `row_id` ,
   ARCTAN2(`x`, `y`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: sinh, op_class: e, example expression: x.sinh(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.SINH does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.sinh()'})
   `row_id` ,
   SINH(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: cosh, op_class: e, example expression: x.cosh(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.COSH does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.cosh()'})
   `row_id` ,
   COSH(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: tanh, op_class: e, example expression: x.tanh(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.TANH does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.tanh()'})
   `row_id` ,
   TANH(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: arcsinh, op_class: e, example expression: x.arcsinh(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.ARCSINH does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.arcsinh()'})
   `row_id` ,
   ARCSINH(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: arccosh, op_class: e, example expression: x.arccosh(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.ARCCOSH does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.arccosh()'})
   `row_id` ,
   ARCCOSH(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: arctanh, op_class: e, example expression: x.arctanh(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.ARCTANH does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.arctanh()'})
   `row_id` ,
   ARCTANH(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: expm1, op_class: e, example expression: y.expm1(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.EXPM1 does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `y`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'y.expm1()'})
   `row_id` ,
   EXPM1(`y`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: log1p, op_class: e, example expression: x.log1p(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.LOG1P does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.log1p()'})
   `row_id` ,
   LOG1P(`x`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: is_inf, op_class: e, example expression: y.is_inf(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FLOAT64)) AND (`y` < CAST('+infinity' AS FLOAT64))) THEN TRUE ELSE FALSE END) AS' at line 16")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `y`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'y.is_inf()'})
   `row_id` ,
   (CASE WHEN `y` IS NULL THEN FALSE WHEN NOT ((`y` > CAST('-infinity' AS FLOAT64)) AND (`y` < CAST('+infinity' AS FLOAT64))) THEN TRUE ELSE FALSE END) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: as_int64, op_class: e, example expression: y.as_int64(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'INT64) AS `new_column`\n  FROM\n   `table_reference_0`\n )\nSELECT  -- .order_rows([' at line 16")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `y`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'y.as_int64()'})
   `row_id` ,
   CAST(`y` AS INT64) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: parse_date, op_class: e, example expression: str_date_col.parse_date(), db: MySQLModel
caught: unsupported format character 'Y' (0x59) at index 375


error (n)
op: parse_datetime, op_class: e, example expression: str_datetime_col.parse_datetime(), db: MySQLModel
caught: unsupported format character 'Y' (0x59) at index 418


error (n)
op: format_datetime, op_class: e, example expression: datetime_col_0.format_datetime(), db: MySQLModel
caught: unsupported format character 'Y' (0x59) at index 416


error (n)
op: format_date, op_class: e, example expression: date_col_0.format_date(), db: MySQLModel
caught: unsupported format character 'Y' (0x59) at index 373


error (n)
op: dayofweek, op_class: e, example expression: date_col_0.dayofweek(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DAYOFWEEK FROM `date_col_0`) AS `new_column`\n  FROM\n   `table_reference_0`\n )\nSE' at line 16")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `date_col_0`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.dayofweek()'})
   `row_id` ,
   EXTRACT(DAYOFWEEK FROM `date_col_0`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: dayofyear, op_class: e, example expression: date_col_0.dayofyear(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DAYOFYEAR FROM `date_col_0`) AS `new_column`\n  FROM\n   `table_reference_0`\n )\nSE' at line 16")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `date_col_0`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.dayofyear()'})
   `row_id` ,
   EXTRACT(DAYOFYEAR FROM `date_col_0`) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: timestamp_diff, op_class: e, example expression: datetime_col_0.timestamp_diff(datetime_col_1), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.TIMESTAMP_DIFF does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `datetime_col_0` ,
   `datetime_col_1`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'datetime_col_0.timestamp_diff(datetime_col_1)'})
   `row_id` ,
   TIMESTAMP_DIFF(`datetime_col_0`, `datetime_col_1`, SECOND) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: date_diff, op_class: e, example expression: date_col_0.date_diff(date_col_1), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.TIMESTAMP_DIFF does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `date_col_0` ,
   `date_col_1`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'date_col_0.date_diff(date_col_1)'})
   `row_id` ,
   TIMESTAMP_DIFF(`date_col_0`, `date_col_1`, DAY) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: base_Sunday, op_class: e, example expression: date_col_1.base_Sunday(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DAYOFWEEK FROM `date_col_1`) - 1) DAY) AS `new_column`\n  FROM\n   `table_referenc' at line 16")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `date_col_1`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'date_col_1.base_Sunday()'})
   `row_id` ,
   DATE_SUB(`date_col_1`, INTERVAL (EXTRACT(DAYOFWEEK FROM `date_col_1`) - 1) DAY) AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: _ngroup, op_class: g, example expression: _ngroup(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OVER ( PARTITION BY `g`  )  AS `new_column`\n  FROM\n   `table_reference_0`\n )\nSEL' at line 17")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': '_ngroup()'}, partition_by=['g'])
   `g` ,
   `row_id` ,
   NGROUP() OVER ( PARTITION BY `g`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: median, op_class: g, example expression: x.median(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OVER ( PARTITION BY `g`  )  AS `new_column`\n  FROM\n   `table_reference_0`\n )\nSEL' at line 18")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.median()'}, partition_by=['g'])
   `g` ,
   `row_id` ,
   MEDIAN(`x`) OVER ( PARTITION BY `g`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: nunique, op_class: g, example expression: x.nunique(), db: MySQLModel
caught: (pymysql.err.NotSupportedError) (1235, "This version of MySQL doesn't yet support '<window function>(DISTINCT ..)'")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.nunique()'}, partition_by=['g'])
   `g` ,
   `row_id` ,
   COUNT(DISTINCT (`x`)) OVER ( PARTITION BY `g`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/tw8g)


difference (w)
op: _count, op_class: g, example expression: _count(), db: MySQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           1
1    a       1           2
2    b       2           1
3  ccc       3           1
DB result:
     g  row_id  new_column
0    a       0         2.0
1    a       1         2.0
2    b       2         1.0
3  ccc       3         1.0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': '_count()'}, partition_by=['g'])
   `g` ,
   `row_id` ,
   SUM(1) OVER ( PARTITION BY `g`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`



error (n)
op: median, op_class: p, example expression: x.median(), db: MySQLModel
caught: (pymysql.err.OperationalError) (1305, 'FUNCTION jmount.MEDIAN does not exist')
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `g` ,
   `x`
  FROM
   `d`
 ) ,
 `project_1` AS (
  SELECT  -- .project({ 'new_column': 'x.median()'}, group_by=['g'])
   `g` ,
   MEDIAN(`x`) AS `new_column`
  FROM
   `table_reference_0`
  GROUP BY
   `g`
 )
SELECT  -- .order_rows(['g'])
 *
FROM
 `project_1`
ORDER BY
 `g`
]
(Background on this error at: https://sqlalche.me/e/14/e3q8)


error (n)
op: bfill, op_class: w, example expression: z.bfill(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`\n  FROM\n   `table_r' at line 18")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.bfill()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   BFILL(`z`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: ffill, op_class: w, example expression: z.ffill(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`\n  FROM\n   `table_r' at line 18")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.ffill()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   FFILL(`z`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: first, op_class: w, example expression: x.first(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '(`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`\n  FROM\n   `t' at line 18")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.first()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   FIRST(`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: last, op_class: w, example expression: x.last(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '(`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`\n  FROM\n   `t' at line 18")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.last()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   LAST(`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: rank, op_class: w, example expression: x.rank(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`\n  FROM\n   `ta' at line 18")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.rank()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   RANK(`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


error (n)
op: cumprod, op_class: w, example expression: x.cumprod(), db: MySQLModel
caught: (pymysql.err.ProgrammingError) (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`\n  FROM\n   `table_r' at line 18")
[SQL: -- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `x` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'x.cumprod()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   PROD(`x`) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`
]
(Background on this error at: https://sqlalche.me/e/14/f405)


difference (w)
op: cumcount, op_class: w, example expression: z.cumcount(), db: MySQLModel
Pandas result (expectation):
     g  row_id  new_column
0    a       0           0
1    a       1           1
2    b       2           0
3  ccc       3           0
DB result:
     g  row_id  new_column
0    a       0         1.0
1    a       1         1.0
2    b       2         1.0
3  ccc       3         0.0
query
-- data_algebra SQL https://github.com/WinVector/data_algebra
--  dialect: MySQLModel 1.4.1
--       string quote: '
--   identifier quote: `
WITH
 `table_reference_0` AS (
  SELECT
   `row_id` ,
   `z` ,
   `g`
  FROM
   `d`
 ) ,
 `extend_1` AS (
  SELECT  -- .extend({ 'new_column': 'z.cumcount()'}, partition_by=['g'], order_by=['row_id'])
   `g` ,
   `row_id` ,
   SUM(CASE WHEN `z` IS NOT NULL THEN 1 ELSE 0 END) OVER ( PARTITION BY `g` ORDER BY `row_id`  )  AS `new_column`
  FROM
   `table_reference_0`
 )
SELECT  -- .order_rows(['g', 'row_id'])
 *
FROM
 `extend_1`
ORDER BY
 `g` ,
 `row_id`


